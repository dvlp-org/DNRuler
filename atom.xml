<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天宇</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-05T13:42:22.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>黄天宇</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kotlin学习笔记二--常用操作符</title>
    <link href="http://yoursite.com/2018/10/05/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://yoursite.com/2018/10/05/Kotlin学习笔记二-常用操作符/</id>
    <published>2018-10-05T11:55:12.000Z</published>
    <updated>2018-10-05T13:42:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="操作符"><a href="#操作符" class="headerlink" title="?操作符"></a>?操作符</h3><p>表示<strong>这个对象可能为空</strong></p><pre><code>//在变量类型后面加上问号表示该变量是可空变量var name: String? = &quot;test&quot;</code></pre><p>返回值类型若可能为空则也需加?</p><pre><code>fun parseInt(str: String): Int? {    if (str == null) return null    else return Integer.parse(str)}</code></pre><p>在变量后加?操作符表示该变量非空就返回表达式值，否则返回null</p><pre><code>var length: Int = b?.length //如果b非空，返回b.length,b为空则返回null</code></pre><h3 id="操作符-1"><a href="#操作符-1" class="headerlink" title="?:操作符"></a>?:操作符</h3><p>该操作符又叫Elvis操作符，表示如果r非空，则使用；否则使用该操作符后面值</p><pre><code>//原来含义val l: Int = if (b != null) b.length else -1//使用Evlis操作符val l = b?.length ?: -1</code></pre><p>即?:左侧表达式非空时，就返回左侧表达式值，否则返回右侧表达式；<br>注意：当前仅当左侧为空时，才会对右侧表达式求值。</p><h3 id="操作符-2"><a href="#操作符-2" class="headerlink" title="!!操作符"></a>!!操作符</h3><p>当变量非空时返回对应变量，否则抛出NULL异常（空指针异常）</p><pre><code>val l = b!!.length//b为空抛出空异常，b不为空则返回b.length值</code></pre><h3 id="与-操作符"><a href="#与-操作符" class="headerlink" title="==与===操作符"></a>==与===操作符</h3><p>==判断值是否相等，===判断值及引用是否完全相等</p><pre><code>val num: Int = 128val a: Int? = numval b: Int? = numprintln(a == b) // trueprintln(a === b) // false</code></pre><h3 id="操作符-in操作符-in操作符"><a href="#操作符-in操作符-in操作符" class="headerlink" title="..操作符 in操作符 !in操作符"></a>..操作符 in操作符 !in操作符</h3><p>a..b代表从a到b，包括a和b，是一个闭区间运算符，而unitl则是半闭区间运算符，代表从a到b的值，包括a不包括b。in代表在一个区间中，!in表示不在一个区间中。</p><pre><code>if (i in 1..10) {//i是否在1到10之间，包括两个端点1和10    println(i)}for (i in 1 until 10) {//i在[1, 10) 包含1不包含10    println(i)}</code></pre><h3 id="downTo函数"><a href="#downTo函数" class="headerlink" title="downTo函数"></a>downTo函数</h3><p>倒叙遍历，区间内循环</p><pre><code>for (i in 100 downTo 1) {    println(i) //这里会倒叙输出}</code></pre><h3 id="step函数"><a href="#step函数" class="headerlink" title="step函数"></a>step函数</h3><p>可以设置任意值的迭代，而不是每次只变化1步</p><pre><code>for (i in 1..100 step 3) print(i) //每次前进3步for (i in 100 downTo 1 step 2) print(i) // 每次减小2</code></pre><h3 id="操作符-3"><a href="#操作符-3" class="headerlink" title="::操作符"></a>::操作符</h3><p>得到类的Class对象</p><pre><code>//java方式跳转ActivitystartActivity(new Intent(this, MainActivity.class))//Kotlin方式跳转ActivitystartActivity(Intent(this@StartActivity, MainActivity::class.java))</code></pre><h3 id="操作符-4"><a href="#操作符-4" class="headerlink" title="@操作符"></a>@操作符</h3><ol><li>限定this的类型<pre><code>class User { inner class State{     fun getUser(): User{         //返回User         return this@User     }     fun getState(): State{         //返回State         return this@State     } }}</code></pre></li><li>作为标签</li></ol><pre><code>//跳出双层forloop@ for (itemA in arraysA) {     var i : Int = 0      for (itemB in arraysB) {         i++         if (itemB &gt; 2) {             break@loop         }         println(&quot;itemB:$itemB&quot;)     }}//从forEach函数跳出fun forEach_label(ints: List&lt;Int&gt;){    var i =2    ints.forEach {        //forEach中无法使用continue和break;//        if (it == 0) continue //编译错误//        if (it == 2) /*break //编译错误 */        print(it)    }     run outer@{         ints.forEach {             if (it == 0) return@forEach //相当于在forEach函数中continue,实际上是从匿名函数返回             if (it == 2) return@outer //相当于在forEach函数中使用break,实际上是跳转到outer之外         }     }    if (i == 3)    {        //每个函数的名字代表一个函数地址，所以函数自动成为标签        return@forEach_label //等同于return    }}//命名函数自定义标签fun fun_run(){    run {        println(&quot;lambda&quot;)    }    var i: Int = run {        return@run 1    }    println(&quot;$i&quot;)    //匿名函数可以通过自定义标签进行跳转和返回    i = run (outer@{        return@outer 2    })    println(i)}</code></pre><h3 id="as-操作符"><a href="#as-操作符" class="headerlink" title="as?操作符"></a>as?操作符</h3><p>当使用 as 转型的时候，可能会经常出现 ClassCastException。 所以，现在可以使as?安全转型，当转型不成功的时候，它会返回 null。</p><p>注：在使用intent传值的时候，会出现空字符串不能用as强制转型，这是应该使用as?</p><pre><code>val m: Int? = a as? Int</code></pre><h3 id="冒号"><a href="#冒号" class="headerlink" title="冒号:"></a>冒号:</h3><p>用于类的继承，变量的定义<br>1、类型和超类型之间的冒号前要有一个空格<br>2、实例和类型之间的冒号前不要空格</p><pre><code>//定义全局变量时var str: String? = null//类的继承与变量定义class TestActivity&lt;T : Serializable&gt;(str: String) : Activity{}</code></pre><h3 id="is操作符"><a href="#is操作符" class="headerlink" title="is操作符"></a>is操作符</h3><p>检查某个实例是否是某个类型，如果判断出属于某个类型，那么判断后的分支中可以直接可当该类型使用，无需显示转换</p><pre><code>fun getStringLength(obj: Any): Int? {        //obj在&amp;&amp;右边自动动转换成&quot;String&quot;类型        if (obj is String &amp;&amp; obj.length &gt; 0)            return obj.length        return null    }</code></pre><h3 id="“””操作符"><a href="#“””操作符" class="headerlink" title="“””操作符"></a>“””操作符</h3><p>三引号的形式用来输入多行文本，也就是说在三引号之间输入的内容将被原样保留，之中的单号和双引号不用转义，其中的不可见字符比如/n和/t都会被保留。</p><pre><code>val str = &quot;&quot;&quot;         one        two            &quot;&quot;&quot;//等价于          val str = &quot;one\ntwo&quot;       val str =  &quot;one&quot; +&quot;\n&quot;+&quot;two&quot;</code></pre><h3 id="操作符-5"><a href="#操作符-5" class="headerlink" title="$操作符"></a>$操作符</h3><p>字符串可以包含模板表达式，及一小段代码，会求值并把结果包含到字符串中。模板字符串以美元符号$开头，由一个简单的名字构成：</p><pre><code>val value:Int=5;val str:String=&quot;the value is $value&quot;println(&quot;itemB:$itemB&quot;)//字符串模板var userInfo = &quot;name:${user.name},  age:$age&quot;//花括号括起来的任意表达式val g:Int=2val h:Int=3val str:String=&quot;g+h=${g+h}&quot;</code></pre><p>注意：转义字符串和原生字符串都支持模板字符串。如果想要在原生字符串中使用$（它不支持反斜杠转义），可以使用以下语法：</p><pre><code>val str:String=&quot;&quot;&quot;the price is ${&#39;$&#39;}199&quot;&quot;&quot;</code></pre><p>_</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;操作符&quot;&gt;&lt;a href=&quot;#操作符&quot; class=&quot;headerlink&quot; title=&quot;?操作符&quot;&gt;&lt;/a&gt;?操作符&lt;/h3&gt;&lt;p&gt;表示&lt;strong&gt;这个对象可能为空&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//在变量类型后面加上问号表示该变量是可空
      
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin学习" scheme="http://yoursite.com/tags/Kotlin%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin学习笔记一</title>
    <link href="http://yoursite.com/2018/10/03/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2018/10/03/Kotlin学习笔记一-基本语法/</id>
    <published>2018-10-03T06:35:14.000Z</published>
    <updated>2018-10-05T13:46:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Kotlin简介"><a href="#Kotlin简介" class="headerlink" title="Kotlin简介"></a>Kotlin简介</h3><p>Kotlin是一门与Swift类似的静态类型JVM语言，由JetBrains设计开发并开源。与Java相比，Kotlin的语法更简洁、更具表达性，而且提供了更多的特性，比如，高阶函数、操作符重载、字符串模板。它与Java高度可互操作，可以同时用在一个项目中。</p><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p><a href="http://kotlinlang.org/" target="_blank" rel="noopener">下载地址</a></p><p><a href="https://try.kotlinlang.org" target="_blank" rel="noopener">在线练习平台</a></p><h4 id="1-Kotlin的基本类型"><a href="#1-Kotlin的基本类型" class="headerlink" title="1.Kotlin的基本类型"></a>1.Kotlin的基本类型</h4><p>基本数据类型位数</p><table><thead><tr><th style="text-align:center">Type</th><th style="text-align:center">Bit width</th></tr></thead><tbody><tr><td style="text-align:center">Double</td><td style="text-align:center">64</td></tr><tr><td style="text-align:center">Float</td><td style="text-align:center">32</td></tr><tr><td style="text-align:center">Long</td><td style="text-align:center">64</td></tr><tr><td style="text-align:center">Int</td><td style="text-align:center">32</td></tr><tr><td style="text-align:center">Short</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">Byte</td><td style="text-align:center">8</td></tr></tbody></table><p>与Java基本数据类型对比</p><table><thead><tr><th style="text-align:center">Java Type</th><th style="text-align:center">Kotlin Type</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">kotlin.Byte</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">kotlin.Short</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">kotlin.Int</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">kotlin.Long</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">kotlin.Char</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">kotlin.Float</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">kotlin.Double</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">kotlin.Boolean</td></tr></tbody></table><p>复杂类型的对比：</p><table><thead><tr><th style="text-align:center">Java Type</th><th style="text-align:center">Kotlin Type</th></tr></thead><tbody><tr><td style="text-align:center">java.lang.Object</td><td style="text-align:center">kotlin.Any!</td></tr><tr><td style="text-align:center">java.lang.Cloneable</td><td style="text-align:center">kotlin.Cloneable!</td></tr><tr><td style="text-align:center">java.lang.Comparable</td><td style="text-align:center">kotlin.Comparable!</td></tr><tr><td style="text-align:center">java.lang.Enum</td><td style="text-align:center">kotlin.Enum!</td></tr><tr><td style="text-align:center">java.lang.Annotation</td><td style="text-align:center">kotlin.Annotation!</td></tr><tr><td style="text-align:center">java.lang.Deprecated</td><td style="text-align:center">kotlin.Deprecated!</td></tr><tr><td style="text-align:center">java.lang.Void</td><td style="text-align:center">kotlin.Nothing!</td></tr><tr><td style="text-align:center">java.lang.CharSequence</td><td style="text-align:center">kotlin.CharSequence!</td></tr><tr><td style="text-align:center">java.lang.String</td><td style="text-align:center">kotlin.String!</td></tr><tr><td style="text-align:center">java.lang.Number</td><td style="text-align:center">kotlin.Number!</td></tr><tr><td style="text-align:center">java.lang.Throwable</td><td style="text-align:center">kotlin.Throwable!</td></tr></tbody></table><p>集合类型的对比：</p><table><thead><tr><th style="text-align:center">Java Type</th><th style="text-align:center">Kotlin Type</th><th style="text-align:center">Kotlin mutable type</th><th style="text-align:center">Loaded platform type</th></tr></thead><tbody><tr><td style="text-align:center">Iterator<t></t></td><td style="text-align:center">Iterator<t></t></td><td style="text-align:center">MutableIterator<t></t></td><td style="text-align:center">(Mutable)Iterator<t>!</t></td></tr><tr><td style="text-align:center">Iterable<t></t></td><td style="text-align:center">Iterable<t></t></td><td style="text-align:center">MutableIterable<t></t></td><td style="text-align:center">(Mutable)Iterable<t>!</t></td></tr><tr><td style="text-align:center">Collection<t></t></td><td style="text-align:center">Collection<t></t></td><td style="text-align:center">MutableCollection<t></t></td><td style="text-align:center">(Mutable)Collection<t>!</t></td></tr><tr><td style="text-align:center">Set<t></t></td><td style="text-align:center">Set<t></t></td><td style="text-align:center">MutableSet<t></t></td><td style="text-align:center">(Mutable)Set<t>!</t></td></tr><tr><td style="text-align:center">List<t></t></td><td style="text-align:center">List<t></t></td><td style="text-align:center">MutableList<t></t></td><td style="text-align:center">(Mutable)List<t>!</t></td></tr><tr><td style="text-align:center">ListIterator<t></t></td><td style="text-align:center">ListIterator<t></t></td><td style="text-align:center">MutableListIterator<t></t></td><td style="text-align:center">(Mutable)ListIterator<t>!</t></td></tr><tr><td style="text-align:center">Map<k, v=""></k,></td><td style="text-align:center">Map<k, v=""></k,></td><td style="text-align:center">MutableMap<k, v=""></k,></td><td style="text-align:center">(Mutable)Map<k, v="">!</k,></td></tr><tr><td style="text-align:center">Map.Entry<k, v=""></k,></td><td style="text-align:center">Map.Entry<k, v=""></k,></td><td style="text-align:center">MutableMap.MutableEntry<k, v=""></k,></td><td style="text-align:center">(Mutable)Map.(Mutable)Entry<k, v="">!</k,></td></tr></tbody></table><p>数组类型的映射：</p><table><thead><tr><th style="text-align:center">Java Type</th><th style="text-align:center">Kotlin Type</th></tr></thead><tbody><tr><td style="text-align:center">int[]</td><td style="text-align:center">kotlin.IntArray!</td></tr><tr><td style="text-align:center">String[]</td><td style="text-align:center">kotlin.Array&lt;(out) String&gt;!</td></tr></tbody></table><h4 id="2-函数的使用"><a href="#2-函数的使用" class="headerlink" title="2.函数的使用"></a>2.函数的使用</h4><p>定义函数使用fun关键字</p><pre><code>fun sub(a: Int, b: Int): Int {    return a - b}</code></pre><p>上面定义一个名为sub的函数，该函数有两个Int类型参数，有一个Int型的返回值，在Kotlin中，一句代码结束可以不用加分号(;)结束，加分号也没问题。在Kotlin中可以对函数进行简写如下：</p><pre><code>fun sub(a: Int, b: Int) = a - b;</code></pre><p>上面fun未显示的给出返回值则Kotlin会自动推测出返回值类型。</p><pre><code>fun prin(a: Int, b: Int): Unit {//没有返回值可以显示的用Unit表示返回    println(a - b) }fun prin(a: Int, b: Int) {//也可以不写出返回值    println(a - b)}</code></pre><h4 id="3-定义常亮和变量"><a href="#3-定义常亮和变量" class="headerlink" title="3. 定义常亮和变量"></a>3. 定义常亮和变量</h4><p>在Kotlin中使用val声明一个常量（只读属性），而使用var声明一个变量。</p><pre><code>fun mytest() {    //使用val关键字声明的常量，和Java中static final一致，声明时需要赋值    val a: Int = 1 //定义时指明常量类型    val b = 2 //自动推测类型    val c: Int //声明一个未赋值的常量时，必须指明类型    // a = 3  //常量值不可修改     //使用var关键字声明一个变量，变量的值可以修改    var year: Int = 2016 //显式指定变量的类型    var month = 5 //自动推断变量类型    var day: Int //声明一个不初始化的变量，必须显式指定类型    month = 6 //变量值可以被修改}</code></pre><h4 id="4-注释"><a href="#4-注释" class="headerlink" title="4. 注释"></a>4. 注释</h4><pre><code>fun comments() {//    注释一行代码//    var s = &quot;hello world&quot;    /*注释一段代码    var a = 8    a++    a--*/}</code></pre><h4 id="5-条件表达式"><a href="#5-条件表达式" class="headerlink" title="5. 条件表达式"></a>5. 条件表达式</h4><pre><code>//正常写法fun max(a: Int, b: Int): Int {    if (a &gt; b)         return a    else         return b}//在kotlin中可以简写为：fun max1(a: Int, b: Int) = if (a &gt; b) a else b</code></pre><h4 id="6-可空类型"><a href="#6-可空类型" class="headerlink" title="6. 可空类型"></a>6. 可空类型</h4><p>在声明变量时在变量类型后加一个问好?表示该变量是可空变量，其值可以为空，在调用时需注意非空判断</p><pre><code>var name: String? = &quot;mytest&quot;name = nullvar sex: String = &quot;male&quot;//sex = null //这句会报错，因为sex是不可空类型</code></pre><p>返回值也可以为可空类型</p><pre><code>fun mytest(s: String): Int? {    if (s == null) {        return null    }    return Integer.parseInt(s)}</code></pre><h4 id="7-类型检查和自动类型转换"><a href="#7-类型检查和自动类型转换" class="headerlink" title="7. 类型检查和自动类型转换"></a>7. 类型检查和自动类型转换</h4><p>在Kotlin中使用is进行类型检查，在检查后不需要显示转换，可直接按检查的类型使用</p><pre><code>fun getStringLength(n: Any): Int?{    if (n is String) {        return n.length    }    return null}</code></pre><h4 id="8-循环"><a href="#8-循环" class="headerlink" title="8. 循环"></a>8. 循环</h4><pre><code>//for循环fun myfor() {    var arr = listOf(1,2,3,4)    for (i in arr.indices) {//索引方式        println(arr[i])    }    for (num in arr) {//直接使用list中对象        println(num)    }}fun mywhile() {    var i = 0    while (i &lt; 10) {        println (&quot;$i&quot;)        i++    }    i = 0    do {        println(i)    } while (i &lt; 10)}</code></pre><h4 id="9-when表达式"><a href="#9-when表达式" class="headerlink" title="9. when表达式"></a>9. when表达式</h4><p>when类似Java中的switch，是一个多分支选择的表达式</p><pre><code>fun main(args: Array&lt;String&gt;) {    testCase(&quot;hello world&quot;)}fun testCase(obj: Any) {    when(obj) {        is String -&gt; {            print(&quot;this is string&quot;)        }        is Int -&gt; {            print(&quot;this is integer&quot;)        }        else -&gt; {            print(&quot;unkown value&quot;)        }    }}</code></pre><h4 id="10-ranges的使用"><a href="#10-ranges的使用" class="headerlink" title="10. ranges的使用"></a>10. ranges的使用</h4><p>(1) 使用in操作符检查一个数是否在某个范围内，!in表示是否不在某个范围内</p><pre><code>/*判断分数是否大于等于90，小于等于100 */fun isGood(score: Int) {    if(score in 90..100) //ranges是闭区间        println(&quot;very good&quot;)    else        println(&quot;not so good&quot;)}</code></pre><p>(2) 检查索引是否越界</p><pre><code>/*检查index是否在数组arr的索引范围内 */fun checkIndex(index: Int, arr: Array&lt;Int&gt;) {    if(index in 0..arr.lastIndex) //arr.lastIndex返回的是数组的最后一位的下标        println(&quot;index in bounds&quot;)    else        println(&quot;index out of bounds&quot;)}</code></pre><p>(3) 遍历一个范围</p><pre><code>for (i in 1..5) {    println(i)}//也可以使用in遍历一个集合fun test(arr: Array&lt;String&gt;) {    for (str in arr) {        println(str)    }}</code></pre><p>这些都是Kotlin的一些基本语法知识，对于入门Kotlin来说需要学的还有很多，Kotlin在简化代码方面做 了很多努力，现在Google官方也宣布Android官方支持的语言是Kotlin，所以未来Kotlin肯定会有很好的发展。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Kotlin简介&quot;&gt;&lt;a href=&quot;#Kotlin简介&quot; class=&quot;headerlink&quot; title=&quot;Kotlin简介&quot;&gt;&lt;/a&gt;Kotlin简介&lt;/h3&gt;&lt;p&gt;Kotlin是一门与Swift类似的静态类型JVM语言，由JetBrains设计开发并开源。
      
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin学习" scheme="http://yoursite.com/tags/Kotlin%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Android中Handler导致内存泄漏的原理分析</title>
    <link href="http://yoursite.com/2018/03/22/Android%E4%B8%ADHandler%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/03/22/Android中Handler导致内存泄漏的原理分析/</id>
    <published>2018-03-22T03:42:34.000Z</published>
    <updated>2018-07-30T14:34:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>在写Android应用程序时，Handler应该是很常见的一个类。我们一般在使用该类时有采用如下方法：</p><pre><code>// 1.新建一个匿名的Handler内部类，并重新handleMessageprivate Handler mHandler = new Handler() {    @Override    public void handleMessage(Message msg) {        switch (msg.what) {            case 1:                //主线程可以更新UI                Log.e(&quot;handler&quot;, &quot;case 1&quot;);                break;            default:                Log.e(&quot;handler&quot;, &quot;default&quot;);                break;        }    }};private void doInBackground() {    new Thread(){        @Override        public void run() {            //2.在工作线程中完成具体的事情            try {                // TODO doSomething();                sleep(6000);            } catch (Exception e) {            }            //3.事情完成后，通过mHandler线程间消息传递给主线程的Handler进行更新操作            mHandler.sendEmptyMessage(1);        }    }.start();}</code></pre><p>上面新建Handler时也可以采用如下方法：</p><pre><code>private Handler mHandler;@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.about_and_feedback);    mContext = this;    mHandler = new MyHandler();}private class MyHandler extends Handler {    @Override    public void handleMessage(Message msg) {        switch (msg.what) {            case 1:                //主线程可以更新UI                Log.e(&quot;handler&quot;, &quot;case 1&quot;);                break;            default:                Log.e(&quot;handler&quot;, &quot;default&quot;);                break;        }    }}</code></pre><p>以上两种方式都是新建了一个匿名的内部类，并直接new给了mHandler变量。采用如上方式使用Handler时会有内存泄漏的风险。</p><h3 id="2-原理剖析"><a href="#2-原理剖析" class="headerlink" title="2. 原理剖析"></a>2. 原理剖析</h3><h4 id="2-1-Android的约定"><a href="#2-1-Android的约定" class="headerlink" title="2.1 Android的约定"></a>2.1 Android的约定</h4><p>在Android中主线程的Looper对象的生命周期是和应用程序的生命周期是一样的，这也就意味在主线程的Looper是一直存在的。同时在Java中非静态内部类或者匿名内部类都是默认持有外部类的引用的，这两个内部类的存在是依赖于外部类的对象的。比如如下例子：</p><pre><code>//OutClass.javapublic class OutClass {    public class InnerClass {    }}//Client.javapublic class Client {    public static void main(String[] args) {        //要想new一个InnerClass，必须先new一个OutClass        //OutClass.InnerClass inn = new OutClass.InnerClass();//这句代码是错误的，会编译不过        OutClass out = new OutClass();        OutClass.InnerClass inn = out.new InnerClass();//这句可以编译过，这里就新建了一个依赖于out这个变量的内部类    }}</code></pre><p>单独new InnerClass()是编译不过的，非静态内部类或者匿名内部类是依赖于外部类的，默认是持有外部类的引用的。</p><h4 id="2-2-具体原理分析"><a href="#2-2-具体原理分析" class="headerlink" title="2.2 具体原理分析"></a>2.2 具体原理分析</h4><p>我们在通过mHandler.sendEmptyMessage(1)时，消息Message会被发送的MessageQueue里面，也就是Looper里面的mQueue，消息Message如果有延迟处理时，会留在MessageQueue里面，而Message是持有mHandler的引用，而mHandler是通过匿名内部类的形式创建的，会默认持有外部类Activity的引用。而我们的Looper对象的生命周期和应用程序生命周期一样长。这样在GC垃圾回收机制进行回收时发现这个Activity居然还有其他引用存在，因而就不会去回收这个Activity。<br><img src="//img-blog.csdn.net/20180322123239909?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L2h0eTEwNTMyNDAxMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="具体原理"></p><h3 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h3><h4 id="3-1-在Activity结束时将Handler里面的Message清空"><a href="#3-1-在Activity结束时将Handler里面的Message清空" class="headerlink" title="3.1 在Activity结束时将Handler里面的Message清空"></a>3.1 在Activity结束时将Handler里面的Message清空</h4><p>由于在Activity结束后，Handler里面的消息还没有被处理导致，消息不处理完Handler的引用就一直存在。因而我们可以在onDestroy中将Handler里面的消息给清空了，这样就不会有消息引用Handler了，也就不会因为Handler引用Activity导致Activity无法释放了。具体代码如下：</p><pre><code>@Overrideprotected void onDestroy() {    super.onDestroy();    //将Handler里面消息清空了。    mHandler.removeCallbacksAndMessages(null);}</code></pre><h4 id="3-2-静态内部类-弱引用"><a href="#3-2-静态内部类-弱引用" class="headerlink" title="3.2 静态内部类+弱引用"></a>3.2 静态内部类+弱引用</h4><p>为了避免非静态内部类&amp;匿名内部类持有外部类引用可以采用静态内部类或者直接在外部编写该Handler的继承类。如果该类需要使用Activity相关变量，可以采用弱引用的方式将Activity的变量传过去。在获取Activity的时候还可以加上判断当前Activity是不是isFinishing的代码，避免因为当前Activity已经进入了finish状态，还去引用这个Activity。具体代码如下：</p><pre><code>public class NoLeakHandler&lt;T&gt; extends Handler {    private final WeakReference&lt;T&gt; mTargetRef;    public NoLeakHandler(T target) {        mTargetRef = new WeakReference(target);    }    public NoLeakHandler(Looper looper, T target) {        super(looper);        mTargetRef = new WeakReference(target);    }    public NoLeakHandler(Callback callback, T target) {        super(callback);        mTargetRef = new WeakReference(target);    }    public NoLeakHandler(Looper looper, Callback callback, T target) {        super(looper, callback);        mTargetRef = new WeakReference(target);    }    @Override    public final void dispatchMessage(Message msg) {        //这里可以判断下当前的Activity是不是处于finish状态，如果处于activity.isFinishing()状态则target也为空        if (checkNotLeak(mTargetRef) != null) {            super.dispatchMessage(msg);        }    }    @Override    public final void handleMessage(Message msg) {        T target;        if ((target = checkNotLeak(mTargetRef)) != null) {            processMessage(target, msg);        }    }    protected void processMessage(T context, Message msg) {}}</code></pre><p>Utils.java</p><pre><code>private static Class&lt;?&gt; sFragmentClassSupport;private static Method sGetActivitySupport;private static Class&lt;?&gt; sFragmentClass;private static Method sGetActivity;static {    try {        sFragmentClassSupport = Class.forName(&quot;android.support.v4.app.Fragment&quot;, false,                Thread.currentThread().getContextClassLoader());        sGetActivitySupport = sFragmentClassSupport.getDeclaredMethod(&quot;getActivity&quot;);    } catch (Exception e) {        sFragmentClassSupport = null;        sGetActivitySupport = null;    }    try {        sFragmentClass = Class.forName(&quot;android.app.Fragment&quot;, false,                Thread.currentThread().getContextClassLoader());        sGetActivity = sFragmentClass.getDeclaredMethod(&quot;getActivity&quot;);    } catch (Exception e) {        sFragmentClass = null;        sGetActivity = null;    }}//该方法主要判断当前的Activity是不是isFinishing，如果是则返回null。public static &lt;T&gt; T checkNotLeak(WeakReference&lt;T&gt; ref) {    T target = (ref != null ? ref.get() : null);    if (target != null) {        Activity activity = null;        //is the target instance which shows in the foreground (usually {@link Activity} or {@link Fragment})        boolean isShowForeground = false;        if ((sFragmentClassSupport != null) &amp;&amp; (sFragmentClassSupport.isInstance(target))) {            isShowForeground = true;            try {                activity = (Activity) sGetActivitySupport.invoke(target, (Object[]) null);            } catch (Exception ignored) {            }        } else if ((target instanceof Activity)) {            isShowForeground = true;            activity = (Activity) target;        } else if ((sFragmentClass != null) &amp;&amp; (sFragmentClass.isInstance(target))) {            isShowForeground = true;            try {                activity = (Activity) sGetActivity.invoke(target, (Object[]) null);            } catch (Exception ignored) {            }        }        if (isShowForeground) {            if ((activity == null) || activity.isFinishing()) {                return null;            }        }    }    return target;}</code></pre><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>Handler导致内存泄漏的原因也就是因为在Looper的MessageQueue里面有还未处理的Message，而该Message又引用了Handler，如果该Handler采用的是非静态内部类或匿名内部类则该Handler又持有外部类Activity的引用，导致了Activity无法是否，因而产生了内存泄漏。<br>在最开始的代码中其中的线程Thread是直接new Thread(){}.start();的，这也会产生内存泄漏，因为该Thread也是匿名内部类，会持有Activity的引用，如果该Thread一直未执行完，也会导致内存泄漏。解决办法还是静态内部类+弱引用的方法。大家可以自己试试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h3&gt;&lt;p&gt;在写Android应用程序时，Handler应该是很常见的一个类。我们一般在使用该类时有采用如下方法：&lt;/p&gt;
&lt;pre
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android源码分析" scheme="http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>解决ViewPager+Fragment预加载导致未显示界面提前加载数据</title>
    <link href="http://yoursite.com/2018/03/06/%E8%A7%A3%E5%86%B3ViewPager+Fragment%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%AF%BC%E8%87%B4%E6%9C%AA%E6%98%BE%E7%A4%BA%E7%95%8C%E9%9D%A2%E6%8F%90%E5%89%8D%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2018/03/06/解决ViewPager+Fragment预加载导致未显示界面提前加载数据/</id>
    <published>2018-03-06T04:05:44.000Z</published>
    <updated>2018-07-30T14:34:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>当我们使用ViewPager+Fragment结构时，由于谷歌在设计ViewPager时会提前加载下一个界面。虽然用户在滑动到下一页时不会感觉卡顿。但这也存在一个问题：当进入Activity时，当前界面和下一个界面均由网络请求时由于预加载了下一页导致同时有两个网络请求，在大多数情况下不显示的界面是不用联网把数据请求下来的。下面通过Fragment提供的setUserVisibleHint方法来解决该问题。</p><h3 id="2-具体分析"><a href="#2-具体分析" class="headerlink" title="2. 具体分析"></a>2. 具体分析</h3><h4 id="2-1-setUserVisibleHint"><a href="#2-1-setUserVisibleHint" class="headerlink" title="2.1 setUserVisibleHint"></a>2.1 setUserVisibleHint</h4><p>在分析之前先讲下setUserVisibleHint方法，官网对该方法的解释为：<a href="https://developer.android.com/reference/android/app/Fragment.html#setUserVisibleHint%28boolean%29" target="_blank" rel="noopener">setUserVisibleHint</a></p><pre><code>Set a hint to the system about whether this fragment&#39;s UI is currently visible to the user. This hint defaults to true and is persistent across fragment instance state save and restore.An app may set this to false to indicate that the fragment&#39;s UI is scrolled out of visibility or is otherwise not directly visible to the user. This may be used by the system to prioritize operations such as fragment lifecycle updates or loader ordering behavior.Note: This method may be called outside of the fragment lifecycle and thus has no ordering guarantees with regard to fragment lifecycle method calls.Note: Prior to Android N there was a platform bug that could cause setUserVisibleHint to bring a fragment up to the started state before its FragmentTransaction had been committed. As some apps relied on this behavior, it is preserved for apps that declare a targetSdkVersion of 23 or lower.</code></pre><p>翻一下就是：</p><pre><code>设置一个标志表明当前Fragment界面是否对用户可见的，默认值是true。并且该值保存在Fragment的实例中。</code></pre><p>下面的Note就大家自己看了，该方法意思也很简单，设置一个标志来表明当前Fragment是否是可见的。该方法有一个参数，其含义是：</p><pre><code>Parameters:isVisibleToUser    boolean: true if this fragment&#39;s UI is currently visible to the user (default), false if it is not.回调传来的是true表明当前Fragment是对用户可见的，false表示对用户不可见。</code></pre><h4 id="2-2-getUserVisibleHint"><a href="#2-2-getUserVisibleHint" class="headerlink" title="2.2 getUserVisibleHint"></a>2.2 getUserVisibleHint</h4><p>官网解释如下：<a href="https://developer.android.com/reference/android/app/Fragment.html#getUserVisibleHint%28%29" target="_blank" rel="noopener">getUserVisibleHint</a>，也就是返回当前的可见性，代码如下：</p><pre><code>public boolean getUserVisibleHint() {        return mUserVisibleHint;    }</code></pre><p>该方法也就是获取mUserVisibleHint。</p><h4 id="2-3-setUserVisibleHint调用时机"><a href="#2-3-setUserVisibleHint调用时机" class="headerlink" title="2.3 setUserVisibleHint调用时机"></a>2.3 setUserVisibleHint调用时机</h4><p>在FragmentPagerAdapter.java中调用了Fragment的setUserVisibleHint，代码如下：</p><pre><code>@Overridepublic Object instantiateItem(ViewGroup container, int position) {    if (mCurTransaction == null) {        mCurTransaction = mFragmentManager.beginTransaction();    }    final long itemId = getItemId(position);    // Do we already have this fragment?    String name = makeFragmentName(container.getId(), itemId);    Fragment fragment = mFragmentManager.findFragmentByTag(name);    if (fragment != null) {        if (DEBUG) Log.v(TAG, &quot;Attaching item #&quot; + itemId + &quot;: f=&quot; + fragment);        mCurTransaction.attach(fragment);    } else {        fragment = getItem(position);        if (DEBUG) Log.v(TAG, &quot;Adding item #&quot; + itemId + &quot;: f=&quot; + fragment);        mCurTransaction.add(container.getId(), fragment,                makeFragmentName(container.getId(), itemId));    }    if (fragment != mCurrentPrimaryItem) {        fragment.setMenuVisibility(false);        //从这可以看出如果加载的不是当前的Fragment就会调用setUserVisibleHint并传入false        fragment.setUserVisibleHint(false);    }    return fragment;}</code></pre><p>还有一处调用为：</p><pre><code>/** * Called to inform the adapter of which item is currently considered to * be the &quot;primary&quot;, that is the one show to the user as the current page. */@Overridepublic void setPrimaryItem(ViewGroup container, int position, Object object) {    Fragment fragment = (Fragment)object;    if (fragment != mCurrentPrimaryItem) {        if (mCurrentPrimaryItem != null) {            mCurrentPrimaryItem.setMenuVisibility(false);            //将当前的Fragment的Visibile置为false。            mCurrentPrimaryItem.setUserVisibleHint(false);        }        if (fragment != null) {            fragment.setMenuVisibility(true);            //这时候也意味着这个fragment要呈现给用户了，传入参数为true            fragment.setUserVisibleHint(true);        }        mCurrentPrimaryItem = fragment;    }}</code></pre><p>以上代码有三处调用，可以看出在初始加载的时候，如果该Fragment不是要显示的Fragment时，在调用setUserVisibleHint的时候传入的就为false，当setPrimaryItem将某个position的Fragment调到前台时，会先把当前正在显示的Fragment的visibility置为false，然后将当前的Fragment的visibility再置为true。</p><h3 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h3><p>预加载Fragment的时候，我们先判断下当前加载的Fragment的visibility是否是true，如果不是true，那么就先不加载，等下次设置setUserVisibleHint的时候再去联网加载。代码如下：<br>BaseFragment.java</p><pre><code>public abstract class BaseFragment extends Fragment {    //当前View是否创建了。    protected boolean isViewInitiated;    //当前数据是否加载了。    protected boolean isDataInitiated;    @Override    public void setUserVisibleHint(boolean isVisibleToUser) {        super.setUserVisibleHint(isVisibleToUser);        prepareFetchData();    }    @Override    public void onActivityCreated(@Nullable Bundle savedInstanceState) {        super.onActivityCreated(savedInstanceState);        isViewInitiated = true;        prepareFetchData();    }    //即使预加载了第二页，但是网络请求不会被预加载    public abstract void getData();    public boolean prepareFetchData() {        return prepareFetchData(false);    }    public boolean prepareFetchData(boolean forceUpdate) {        if (getUserVisibleHint() &amp;&amp; isViewInitiated &amp;&amp; (!isDataInitiated || forceUpdate)) {            getData();            isDataInitiated = true;            return true;        }        return false;    }}</code></pre><p>在使用的时候，也很方便，直接继承BaseFragment，然后实现getData()函数实现联网请求。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>解决这个还是比较容易的，方法就是当当前Fragment的visibility为true的时候才去联网请求数据。具体办法也就是利用Fragment给的回调函数setUserVisibileHint，然后获取显示状态。没加载数据则联网加载数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h3&gt;&lt;p&gt;当我们使用ViewPager+Fragment结构时，由于谷歌在设计ViewPager时会提前加载下一个界面。虽然用户在
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="ViewPager+Fragment预加载" scheme="http://yoursite.com/tags/ViewPager-Fragment%E9%A2%84%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Android NDK开发系列教程5：局部引用，全局引用，弱全局引用</title>
    <link href="http://yoursite.com/2018/02/06/Android-NDK%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B5%EF%BC%9A%E5%B1%80%E9%83%A8%E5%BC%95%E7%94%A8%EF%BC%8C%E5%85%A8%E5%B1%80%E5%BC%95%E7%94%A8%EF%BC%8C%E5%BC%B1%E5%85%A8%E5%B1%80%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2018/02/06/Android-NDK开发系列教程5：局部引用，全局引用，弱全局引用/</id>
    <published>2018-02-06T14:30:03.000Z</published>
    <updated>2018-07-30T14:34:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>从Java虚拟机创建的对象当传入到native层时会产生一个引用，在进行垃圾回收时如果有native的引用，改对象同样也不会被回收。在native引用中分局部引用和全局引用。</p><h4 id="1-1-局部引用"><a href="#1-1-局部引用" class="headerlink" title="1.1 局部引用"></a>1.1 局部引用</h4><p>局部引用又称本地引用，大多数见到的引用都是局部引用，例如通过NewLocalRef和各种JNI接口创建（FindClass、NewObject、GetObjectClass和NewCharArray等），局部引用只会在本次native调用中有效，当本次调用结束后该引用即被自动释放。局部引用会阻止GC进行回收。同时也可以调用DeleteLocalRef函数来手动释放（比如在循环里面用到了局部引用而退出循环没有使用该局部引用，那么就需要在循环中释放该局部引用）。通常使用NewObject创建的实例返回的也是局部引用。千万不要把局部引用保存为c++的全局变量或者把它定义为静态变量，局部引用的有效期是一次Java本地调用。<br>JNI提供了一系列函数来管理局部引用的生命周期。这些函数包括：EnsureLocalCapacity、NewLocalRef、PushLocalFrame、PopLocalFrame、DeleteLocalRef。</p><pre><code>    //申请扩充局部引用的最大个数限制，返回值等于0的时候表示成功,&gt;0时表示内存溢出。默认至少16个局部引用可以使用，引用数超出时报FatalError    jint (*EnsureLocalCapacity)(JNIEnv*, jint);    /* PushLocalFrame是一个创建本地引用新作用域的有用函数，这使得PushLocalFrame函数可以释放其使用的框架中所有已分配的本地引用。当该函数被调用时，本地引用的最低数量将在本框架中被创建。该函数如果执行成功则返回0，如果由于错误抛出一个OutOfMemoryException，则返回一个负值。*/       jint PushLocalFrame(jint capacity);    /*PopLocalFrame函数释放当前框架中的所有本地引用（弹出一个框架）。因为存储该函数的结果（返回值）可能会导致在即将被弹出的框架中创建一个本地引用，该函数接收一个可以导致引用在当前框架被弹出之后的最高框架中创建的参数。这就确保可以维护一个存储PopLocalFrame函数结果的引用。*/    jobject PopLocalFrame(jobject result);</code></pre><p>PushLocalFrame为当前函数中局部引用创建了一个引用堆栈，在每遍历一次调用(*env)-&gt;GetObjectArrayElement(env, arr, i);返回一个局部引用时，JVM会自动将该引用压入当前局部引用栈中。而PopLocalFrame负责将栈中所有引用释放。这样一来，Push/PopLocalFrame函数对提供了对局部引用生命周期更方便的管理，不用再去一个个Delete了。</p><h4 id="1-2-全局引用"><a href="#1-2-全局引用" class="headerlink" title="1.2 全局引用"></a>1.2 全局引用</h4><p>全局引用可以在当前线程使用，也可以在其他线程使用，可以保存在本地的static静态变量或全局变量中，全局引用需要调用NewGlobalRel函数创建，释放时采用ReleaseGlobalRef函数释放。有效作用域在创建后，一直到调用ReleaseGlobalRef释放时。</p><h4 id="1-3-弱全局引用"><a href="#1-3-弱全局引用" class="headerlink" title="1.3 弱全局引用"></a>1.3 弱全局引用</h4><p>在Java1.2中，新增了弱全局引用，与全局变量一样其创建、删除均需要编程写出，也可以在本地多个代码中使用，也可以跨进程使用。不一样的是，它的存在不影响垃圾回收机制对该引用所指向对象实例的回收。其创建采用NewWeakGlobalRef，释放采用ReleaseWeakGlobalRel。</p><p>以上涉及的函数主要有以下几个：</p><pre><code class="c++">//创建局部引用jobject NewLocalRef(jobject obj);//释放局部引用void DeleteLocalRef(jobject obj);//创建全局引用jobject NewGlobalRef(jobject obj);//释放全局引用void DeleteGobalRef(jobject obj);//创建弱全局引用jobject NewWeakGlobalRef(jobject obj);//释放弱全局引用void DeleteWeakGlobalRef(jobject obj);//该方法判断两个引用是否相等，对于弱全局引用如果对比的是NULL那么还可以判断该引用指向的对象是否被回收jboolean IsSameObject(jobject obj1 , jobject obj2);</code></pre><p>上述三中引用会影响内存的回收，在C/C++中没有向Java一样的垃圾回收机制，自己申请的内存要记得自己去释放了，否则会导致内存泄漏。虽然现在C/C++里面也有智能指针，但相对而言这个智能指针用起来不如Java。所以在C的世界里要遵循谁申请，谁释放的基本原则。</p><h3 id="2-举个栗子"><a href="#2-举个栗子" class="headerlink" title="2. 举个栗子"></a>2. 举个栗子</h3><p>上面介绍了基本知识，下面给出相应的例子来进行说明下。</p><h4 id="2-1局部引用"><a href="#2-1局部引用" class="headerlink" title="2.1局部引用"></a>2.1局部引用</h4><pre><code>    //1. 局部引用不要存储在static变量中，即使存了下次也不能用    //static jclass cls;    //以下创建的局部引用都放入到栈中    env-&gt;PushLocalFrame(16);    jclass cls;    if (!cls) {//这里就错误了，前一次方法完成后jvm会释放局部引用，这里static存的值仅第一次有效        cls = env-&gt;GetObjectClass(instance);//这里的cls是局部引用    }    //删除栈里面的局部引用    env-&gt;PopLocalFrame(NULL);    env-&gt;EnsureLocalCapacity(20);//将本地引用的最大限制改为20    //下面可以进行其他操作。。。</code></pre><p>在局部引用中要注意以下几方面：</p><ol><li>循环体内创建的局部引用，要在循环体内就直接释放了。</li><li>编写的工具函数，里面创建的局部引用，要在该工具函数里面释放了。</li><li>局部引用引用了一个大的Java对象，这时候一定一定要早点释放了。</li><li>局部引用不要缓存在native层</li></ol><h4 id="2-2-全局引用"><a href="#2-2-全局引用" class="headerlink" title="2.2 全局引用"></a>2.2 全局引用</h4><pre><code>extern &quot;C&quot;JNIEXPORT void JNICALLJava_zqc_com_example_NativeTest_jniGlobalRef(JNIEnv *env, jobject instance) {    static jobject obj;    static jclass pCls;    if (obj) {//第二次点击时，这里就不会空        //由于obj和personCls被保存为全局引用了，所有这里使用仍然有效        jmethodID getId = env-&gt;GetMethodID(pCls, &quot;getName&quot;, &quot;()Ljava/lang/String;&quot;);        jstring name = (jstring) env-&gt;CallObjectMethod(obj, getId);        LOGE(&quot;obj is not null, name:%s&quot;, jstringToChar(env, name));        return;    }    if (!pCls) {//为空就去新建        jclass tmpCls = env-&gt;FindClass(&quot;zqc/com/example/Person&quot;);        pCls = (jclass) env-&gt;NewGlobalRef(tmpCls);        env-&gt;DeleteLocalRef(tmpCls);    }    jmethodID conMid = env-&gt;GetMethodID(pCls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);    jobject tmpObj = env-&gt;NewObject(pCls, conMid);    jmethodID setId = env-&gt;GetMethodID(pCls, &quot;setName&quot;, &quot;(Ljava/lang/String;)V&quot;);    env-&gt;CallVoidMethod(tmpObj, setId, env-&gt;NewStringUTF(&quot;看看姓名&quot;));    obj = env-&gt;NewGlobalRef(tmpObj);    env-&gt;DeleteLocalRef(tmpObj);}</code></pre><h4 id="2-3-弱全局引用"><a href="#2-3-弱全局引用" class="headerlink" title="2.3 弱全局引用"></a>2.3 弱全局引用</h4><p>弱全局引用和全局引用基本差不多，最大的区别就是弱全局引用不影响GC的回收。在使用弱全局引用的时候一定要注意，使用前要检查下是不是被GC回收了。</p><pre><code>extern &quot;C&quot;JNIEXPORT void JNICALLJava_zqc_com_example_NativeTest_jniWeakGlobalRef(JNIEnv *env, jobject instance) {    static jclass pCls;    if (!pCls) {        jclass tmpCls = env-&gt;FindClass(&quot;zqc/com/example/Person&quot;);        pCls = (jclass) env-&gt;NewWeakGlobalRef(tmpCls);        env-&gt;DeleteLocalRef(tmpCls);    }    //除了第一次需要FindClass外，在没有回收pCls之前都可以使用    //这里使用...    //可以手动释放    //env-&gt;DeleteWeakGlobalRef(pCls);}</code></pre><h3 id="3-引用的比较"><a href="#3-引用的比较" class="headerlink" title="3. 引用的比较"></a>3. 引用的比较</h3><p>jni提供了相应的函数</p><pre><code>jboolean IsSameObject(jobject ref1, jobject ref2){ return functions-&gt;IsSameObject(this, ref1, ref2); }</code></pre><p>如果两个引用指向同一个实例则返回JNI_TRUE，否则返回JNI_FALSE。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h3&gt;&lt;p&gt;从Java虚拟机创建的对象当传入到native层时会产生一个引用，在进行垃圾回收时如果有native的引用，改对象同样也
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android JNI开发" scheme="http://yoursite.com/tags/Android-JNI%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Android NDK开发系列教程4：对类变量进行操作</title>
    <link href="http://yoursite.com/2018/02/04/Android-NDK%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B4%EF%BC%9A%E5%AF%B9%E7%B1%BB%E5%8F%98%E9%87%8F%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/02/04/Android-NDK开发系列教程4：对类变量进行操作/</id>
    <published>2018-02-04T02:54:57.000Z</published>
    <updated>2018-07-30T14:34:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>通常我们也可以直接利用jni来访问和处理类的变量，不一定非要通过Java方法来操作Java类变量。对类变量操作时，类的静态变量和类的实例变量的操作稍微有些不同，下面进行讲解。</p><h3 id="对类的静态变量进行操作"><a href="#对类的静态变量进行操作" class="headerlink" title="对类的静态变量进行操作"></a>对类的静态变量进行操作</h3><p>类的静态变量属于类，是所有该类实例共享的。操作该变量时，不需要指定具体的实例是哪个。</p><pre><code>jclass clazz;  jfieldID fid;  jint num;  //1.获取类的Class引用  clazz = env-&gt;FindClass(&quot;zqc/com/example/Person&quot;);  if (clazz == NULL) {    // 错误处理  return;  }  //2.获取类静态变量num的属性ID  fid = env-&gt;GetStaticFieldID( clazz, &quot;num&quot;, &quot;I&quot;);  if (fid == NULL) {  return;  }  // 3.获取静态变量num的值  num = env-&gt;GetStaticIntField(clazz,fid);  printf(&quot;In C---&gt;ClassField.num = %d\n&quot;, num);  // 4.修改静态变量num的值  env-&gt;SetStaticIntField(clazz, fid, 80);</code></pre><p>主要步骤就是代码里面注释的。</p><h3 id="对类的实例变量进行操作"><a href="#对类的实例变量进行操作" class="headerlink" title="对类的实例变量进行操作"></a>对类的实例变量进行操作</h3><p>代码如下：</p><pre><code>jclass clazz;  jfieldID fid;  jstring j_str;  jstring j_newStr;  const char *c_str = NULL;  // 1.获取类的Class引用,obj是该类的某个实例jobject obj;clazz = env-&gt;GetObjectClass(obj);  if (clazz == NULL) {  return;  }  // 2. 获取类实例变量str的属性ID  fid = env-&gt;GetFieldID(clazz,&quot;str&quot;, &quot;Ljava/lang/String;&quot;);  if (clazz == NULL) {  return;  }  // 3. 获取实例变量str的值  j_str = (jstring)env-&gt;GetObjectField(obj,fid);  // 4. 将unicode编码的java字符串转换成C风格字符串  c_str = env-&gt;GetStringUTFChars(j_str,NULL);  if (c_str == NULL) {  return;  }  printf(&quot;In C---&gt;ClassField.str = %s\n&quot;, c_str);  env-&gt;ReleaseStringUTFChars(j_str, c_str);  // 5. 修改实例变量str的值  j_newStr = env-&gt;NewStringUTF(&quot;This is C String&quot;);  if (j_newStr == NULL) {  return;  }  env-&gt;SetObjectField(obj, fid, j_newStr);  // 6.删除局部引用  env-&gt;DeleteLocalRef(clazz);  env-&gt;DeleteLocalRef(j_str);  env-&gt;DeleteLocalRef(j_newStr);</code></pre><p>JNI开发也有JNI开发的套路，按照上面套路来，即可修改类的实例变量。操作过程也很好理解，我们在native操作的时候都需要借助JNI提供的函数获取相应的引用。利用引用去进行操作。由于JNI函数是直接操作JVM中的数据结构，所以即使是private的变量，我们也可以进行修改。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>由于JNI函数是直接操作JVM中的数据结构，不受Java访问修饰符的限制。即，在本地代码中可以调用JNI函数可以访问Java对象中的非public属性和方法</li><li><p>访问和修改静态变量操作步聚：</p><ol><li><p>调用FindClass函数获取类的Class引用</p></li><li><p>调用GetStaticFieldID函数获取Class引用中某个静态变量ID</p></li><li><p>调用GetStaticXXXField函数获取静态变量的值，需要传入变量所属Class的引用和变量ID</p></li><li><p>调用SetStaticXXXField函数设置静态变量的值，需要传入变量所属Class的引用、变量ID和变量的值</p></li></ol></li><li><p>访问和修改实例变量操作步聚：</p><ol><li><p>调用GetObjectClass函数获取实例对象的Class引用</p></li><li><p>调用GetFieldID函数获取Class引用中某个实例变量的ID</p></li><li><p>调用GetXXXField函数获取变量的值，需要传入实例变量所属对象和变量ID</p></li><li><p>调用SetXXXField函数修改变量的值，需要传入实例变量所属对象、变量ID和变量的值</p></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常我们也可以直接利用jni来访问和处理类的变量，不一定非要通过Java方法来操作Java类变量。对类变量操作时，类的静态变量和类的实例变量的操作稍微有些不同，下面进行讲解。&lt;/p&gt;
&lt;h3 id=&quot;对类的静态变量进行操作&quot;&gt;&lt;a href=&quot;#对类的静态变量进行操作&quot; c
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android JNI开发" scheme="http://yoursite.com/tags/Android-JNI%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Android NDK开发系列教程3：基本方法调用及传参（续）</title>
    <link href="http://yoursite.com/2018/02/02/Android-NDK%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B3%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%8F%8A%E4%BC%A0%E5%8F%82%EF%BC%88%E7%BB%AD%EF%BC%89/"/>
    <id>http://yoursite.com/2018/02/02/Android-NDK开发系列教程3：基本方法调用及传参（续）/</id>
    <published>2018-02-02T14:25:43.000Z</published>
    <updated>2018-07-30T14:34:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一节主要讲解Java向native传参，下面主要讲解从<em>native传相应的数据到java层</em>。<br>接着上一节，下面主要讲解内容如下：</p><ol><li>native向java返回字符串类型</li><li>native向java返回java对象</li><li>native向java返回数组类型</li><li>native向Java返回List对象<br>对于上面的每个都给出对应的例子。<br>本节所有案例代码均已放到GitHub上，欢迎下载：<br><a href="https://github.com/huangtianyu/JNILearnCourse" target="_blank" rel="noopener">https://github.com/huangtianyu/JNILearnCourse</a></li></ol><h4 id="1-native向java返回字符串类型"><a href="#1-native向java返回字符串类型" class="headerlink" title="1. native向java返回字符串类型"></a>1. native向java返回字符串类型</h4><p>传基本数据类型很简单，是什么就传什么就行。传字符串类型也很简单，具体jni代码如下：</p><pre><code>extern &quot;C&quot;JNIEXPORT jstring JNICALLJava_zqc_com_example_NativeTest_jni2javaMethod1(JNIEnv *env, jobject instance) {    //jstring NewStringUTF(const char* bytes),jstring NewString(const jchar* unicodeChars, jsize len)    char *returnValue = &quot;你在native做你的操作后，生成char*后，通过env-&gt;NewStringUTF即可返回Java的String类型&quot;;    return env-&gt;NewStringUTF(returnValue);}</code></pre><p>其中最主要用的是以下几个方法：</p><pre><code>    //创建Unicode格式的jstring串    jstring NewString(const jchar* unicodeChars, jsize len)    { return functions-&gt;NewString(this, unicodeChars, len); }    //获取jstring长度    jsize GetStringLength(jstring string)    { return functions-&gt;GetStringLength(this, string); }    //获取jstring对应的字符串，isCopy表示是否拷贝生成副本。    //这个函数返回一个指向特定jstring中字符顺序的指针，该指针保持有效直到ReleaseStringChars函数被调用：    const jchar* GetStringChars(jstring string, jboolean* isCopy)    { return functions-&gt;GetStringChars(this, string, isCopy); }    //释放指针    void ReleaseStringChars(jstring string, const jchar* chars)    { functions-&gt;ReleaseStringChars(this, string, chars); }    ////创建UTF-8格式的jstring串    jstring NewStringUTF(const char* bytes)    { return functions-&gt;NewStringUTF(this, bytes); }    //获取utf字符串的长度    jsize GetStringUTFLength(jstring string)    { return functions-&gt;GetStringUTFLength(this, string); }    //同GetStringChars    const char* GetStringUTFChars(jstring string, jboolean* isCopy)    { return functions-&gt;GetStringUTFChars(this, string, isCopy); }    //同ReleaseStringChars    void ReleaseStringUTFChars(jstring string, const char* utf)    { functions-&gt;ReleaseStringUTFChars(this, string, utf); }</code></pre><p>以上是处理字符串常用的一些方法。</p><h4 id="2-native向java返回java对象"><a href="#2-native向java返回java对象" class="headerlink" title="2 native向java返回java对象"></a>2 native向java返回java对象</h4><p>具体看native的代码如下：</p><pre><code>extern &quot;C&quot;JNIEXPORT jobject JNICALLJava_zqc_com_example_NativeTest_jni2javaMethod2(JNIEnv *env, jobject instance) {    jclass pcls = env-&gt;FindClass(&quot;zqc/com/example/Person&quot;);    jmethodID constructor = env-&gt;GetMethodID(pcls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);    jmethodID setIdMid = env-&gt;GetMethodID(pcls, &quot;setId&quot;, &quot;(J)V&quot;);    jmethodID setNameMid = env-&gt;GetMethodID(pcls, &quot;setName&quot;, &quot;(Ljava/lang/String;)V&quot;);    jmethodID setAgeMid = env-&gt;GetMethodID(pcls, &quot;setName&quot;, &quot;(I)V&quot;);    jobject person = env-&gt;NewObject(pcls, constructor);    env-&gt;CallVoidMethod(person, setIdMid, 100L);    env-&gt;CallVoidMethod(person, setNameMid, env-&gt;NewStringUTF(&quot;天宇&quot;));    env-&gt;CallVoidMethod(person, setAgeMid, 18);    return person;}</code></pre><p>常用新建Object的方法由以下几个：</p><pre><code>    //将传递给构造函数的所有参数紧跟着放在 methodID 参数的后面。NewObject() 收到这些参数后，将把它们传给所要调用的Java 方法。    jobject NewObject(jclass clazz, jmethodID methodID, ...)    {        va_list args;        va_start(args, methodID);        jobject result = functions-&gt;NewObjectV(this, clazz, methodID, args);        va_end(args);        return result;    }    //将传递给构造函数的所有参数放在 va_list 类型的参数 args 中，该参数紧跟着放在 methodID 参数的后面。NewObject() 收到这些参数后，将把它们传给所要调用的 Java 方法。    jobject NewObjectV(jclass clazz, jmethodID methodID, va_list args)    { return functions-&gt;NewObjectV(this, clazz, methodID, args); }    //将传递给构造函数的所有参数放在jvalues类型的数组args中，该数组紧跟着放在methodID参数的后面。NewObject() 收到数组中的这些参数后，将把它们传给所要调用的 Java 方法。    jobject NewObjectA(jclass clazz, jmethodID methodID, jvalue* args)    { return functions-&gt;NewObjectA(this, clazz, methodID, args); }    //测试对象是否为某个类的实例。    jboolean IsInstanceOf(jobject obj, jclass clazz)    { return functions-&gt;IsInstanceOf(this, obj, clazz); }    //测试两个引用是否引用同一 Java 对象。    jboolean IsSameObject(jobject ref1, jobject ref2)    { return functions-&gt;IsSameObject(this, ref1, ref2); }    //分配新 Java 对象而不调用该对象的任何构造函数。返回该对象的引用。    //该方法会抛出：InstantiationException：如果该类为一个接口或抽象类。OutOfMemoryError：如果系统内存不足。    jobject AllocObject(jclass clazz)    { return functions-&gt;AllocObject(this, clazz); }</code></pre><h4 id="3-native向java返回数组类型"><a href="#3-native向java返回数组类型" class="headerlink" title="3 native向java返回数组类型"></a>3 native向java返回数组类型</h4><h5 id="3-1-基本类型数组"><a href="#3-1-基本类型数组" class="headerlink" title="3.1 基本类型数组"></a>3.1 基本类型数组</h5><p>这里直接看native层代码如下：</p><pre><code>extern &quot;C&quot;JNIEXPORT jintArray JNICALLJava_zqc_com_example_NativeTest_jni2javaMethod3(JNIEnv *env, jobject instance) {    int nat[] = {2, 1, 4, 3, 5};    jintArray jnat = env-&gt;NewIntArray(5);    env-&gt;SetIntArrayRegion(jnat, 0, 5, nat);    return jnat;}</code></pre><p>基本数据类型数组都有相应的env-&gt;NewXXXArray(jsize length);通过该方法可以生成对应的数组。</p><pre><code>jbooleanArray NewBooleanArray(jsize length)    { return functions-&gt;NewBooleanArray(this, length); }    jbyteArray NewByteArray(jsize length)    { return functions-&gt;NewByteArray(this, length); }    jcharArray NewCharArray(jsize length)    { return functions-&gt;NewCharArray(this, length); }    jshortArray NewShortArray(jsize length)    { return functions-&gt;NewShortArray(this, length); }    jintArray NewIntArray(jsize length)    { return functions-&gt;NewIntArray(this, length); }    jlongArray NewLongArray(jsize length)    { return functions-&gt;NewLongArray(this, length); }    jfloatArray NewFloatArray(jsize length)    { return functions-&gt;NewFloatArray(this, length); }    jdoubleArray NewDoubleArray(jsize length)    { return functions-&gt;NewDoubleArray(this, length); }</code></pre><p>在生成了对应的数组后，可以通过setXXXArrayRegion(jxxxArray array, jsize start, jsize len,  const jchar* buf)来填充数组</p><pre><code>    void SetBooleanArrayRegion(jbooleanArray array, jsize start, jsize len,        const jboolean* buf)    { functions-&gt;SetBooleanArrayRegion(this, array, start, len, buf); }    void SetByteArrayRegion(jbyteArray array, jsize start, jsize len,        const jbyte* buf)    { functions-&gt;SetByteArrayRegion(this, array, start, len, buf); }    void SetCharArrayRegion(jcharArray array, jsize start, jsize len,        const jchar* buf)    { functions-&gt;SetCharArrayRegion(this, array, start, len, buf); }    void SetShortArrayRegion(jshortArray array, jsize start, jsize len,        const jshort* buf)    { functions-&gt;SetShortArrayRegion(this, array, start, len, buf); }    void SetIntArrayRegion(jintArray array, jsize start, jsize len,        const jint* buf)    { functions-&gt;SetIntArrayRegion(this, array, start, len, buf); }    void SetLongArrayRegion(jlongArray array, jsize start, jsize len,        const jlong* buf)    { functions-&gt;SetLongArrayRegion(this, array, start, len, buf); }    void SetFloatArrayRegion(jfloatArray array, jsize start, jsize len,        const jfloat* buf)    { functions-&gt;SetFloatArrayRegion(this, array, start, len, buf); }    void SetDoubleArrayRegion(jdoubleArray array, jsize start, jsize len,        const jdouble* buf)    { functions-&gt;SetDoubleArrayRegion(this, array, start, len, buf); }</code></pre><h5 id="3-2-对象类型数组"><a href="#3-2-对象类型数组" class="headerlink" title="3.2 对象类型数组"></a>3.2 对象类型数组</h5><p>直接看native代码：</p><pre><code>extern &quot;C&quot;JNIEXPORT jobjectArray JNICALLJava_zqc_com_example_NativeTest_jni2javaMethod4(JNIEnv *env, jobject instance) {    jclass cls = env-&gt;FindClass(&quot;zqc/com/example/Person&quot;);    jmethodID cMid = env-&gt;GetMethodID(cls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);    jclass pcls = env-&gt;FindClass(&quot;zqc/com/example/Person&quot;);    jmethodID cmid = env-&gt;GetMethodID(pcls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);    jmethodID setNameMid = env-&gt;GetMethodID(pcls, &quot;setName&quot;, &quot;(Ljava/lang/String;)V&quot;);    jmethodID setAgeMid = env-&gt;GetMethodID(pcls, &quot;setAge&quot;, &quot;(I)V&quot;);    jobject obj = env-&gt;NewObject(pcls, cmid);    env-&gt;CallVoidMethod(obj, setNameMid, env-&gt;NewStringUTF(&quot;天宇&quot;));    int len = 3;    jobjectArray joa = env-&gt;NewObjectArray(len, cls, obj);    for (int i = 0; i &lt; len; ++i) {        jobject tmp = env-&gt;GetObjectArrayElement(joa,i);        env-&gt;CallVoidMethod(tmp, setAgeMid, i + 10);    }    return joa;}</code></pre><p>其在native生成的方法是<code>   jobjectArray joa = env-&gt;NewObjectArray(len, cls, obj);</code></p><pre><code>//第一个参数表示生成的长度，第二参数表示里面元素的对象类，第三个表示原始初始化时的值。在生成后每个元素都是该值。jobjectArray NewObjectArray(jsize length, jclass elementClass,        jobject initialElement)    { return functions-&gt;NewObjectArray(this, length, elementClass,        initialElement); }</code></pre><h4 id="4-native向Java返回List对象"><a href="#4-native向Java返回List对象" class="headerlink" title="4 native向Java返回List对象"></a>4 native向Java返回List对象</h4><p>直接看native代码如下：</p><pre><code>extern &quot;C&quot;JNIEXPORT jobject JNICALLJava_zqc_com_example_NativeTest_jni2javaMethod5(JNIEnv *env, jobject instance) {    jclass listCls = env-&gt;FindClass(&quot;java/util/ArrayList&quot;);//获得ArrayList类引用    jmethodID  listCon = env-&gt;GetMethodID(listCls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);//获取构造函数的methodID    jmethodID addMid = env-&gt;GetMethodID(listCls,&quot;add&quot;,&quot;(Ljava/lang/Object;)Z&quot;);//获取add函数的methodID    jobject listObj = env-&gt;NewObject(listCls, listCon);//利用NewObject创建一个ArrayList对象    jobject jperon = Java_zqc_com_example_NativeTest_jni2javaMethod2(env, instance);//利用上面方法新建一个Person对象    env-&gt;CallBooleanMethod(listObj, addMid, jperon);//在listObj中add一个Person对象    //返回ArrayList的对象    return listObj;}</code></pre><p>对应jni而言，List，ArrayList以及Map，HashMap，Set，HashSet都只是一个Object，对应于jni而言也就都是jobject，操作jobject都可以用最开始介绍的方法。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>jni里面的方法很多，多用用就熟悉了。常用的上面都有，自己之前还总结了很多常用的类型转换函数。以后有时间再写篇博客分享下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一节主要讲解Java向native传参，下面主要讲解从&lt;em&gt;native传相应的数据到java层&lt;/em&gt;。&lt;br&gt;接着上一节，下面主要讲解内容如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;native向java返回字符串类型&lt;/li&gt;
&lt;li&gt;native向java返回java对
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android NDK开发，JNI开发" scheme="http://yoursite.com/tags/Android-NDK%E5%BC%80%E5%8F%91%EF%BC%8CJNI%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title> Android NDK开发系列教程2：基本方法调用及传参</title>
    <link href="http://yoursite.com/2018/02/02/Android-NDK%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B2%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%8F%8A%E4%BC%A0%E5%8F%82/"/>
    <id>http://yoursite.com/2018/02/02/Android-NDK开发系列教程2：基本方法调用及传参/</id>
    <published>2018-02-02T13:56:11.000Z</published>
    <updated>2018-07-30T14:34:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>有时候我写了个Java层的方法，希望native层也能够调用（尤其是一个实体类的get，set方法在native一般都会用到）。这在jni开发中也很常见，jni.h中也提供了很多方法。下面利用具体实例进行说明。这里直接使用AS3.0里面的CMake进行编译了，之后会讲解下Android.mk和Application.mk的用法和含义。这里我主要介绍一下几个：</p><ol><li>java向native传递常用基本数据类型和字符串类型</li><li>java向native传递数组类型</li><li>java向native传递自定义java对象</li><li>java向native传递List对象</li></ol><h4 id="1-1-java和jni类型对照表"><a href="#1-1-java和jni类型对照表" class="headerlink" title="1.1 java和jni类型对照表"></a>1.1 java和jni类型对照表</h4><p>在我们调用方法时会用到方法的签名，使用类变量时需要用该变量对应的jni类型。下面给出对应的类型对照表。</p><ol><li>基本数据类型对照表：<br><img src="http://img.blog.csdn.net/20180201185144006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li><li>对象类型对照表：<br><img src="http://img.blog.csdn.net/20180201185721731?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li><li>简写对应表<br><img src="http://img.blog.csdn.net/20180202143637829?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><h3 id="2-具体例子"><a href="#2-具体例子" class="headerlink" title="2. 具体例子"></a>2. 具体例子</h3><h4 id="2-1-java向native传递常用基本数据类型和字符串类型"><a href="#2-1-java向native传递常用基本数据类型和字符串类型" class="headerlink" title="2.1 java向native传递常用基本数据类型和字符串类型"></a>2.1 java向native传递常用基本数据类型和字符串类型</h4>强大的AS在你写了java的native方法后，直接快捷键按Alt+Enter后即可生成对应的方法。<br>java层的方法：<pre><code>package zqc.com.example;public class NativeTest { // Used to load the &#39;native-lib&#39; library on application startup. static {     System.loadLibrary(&quot;native-lib&quot;); } //定义一个native方法，然后传入基本数据类型和String型 public native void java2jniMethod1(boolean b, int i, float f, String s);}</code></pre>生成后的native方法：<pre><code>extern &quot;C&quot;JNIEXPORT void JNICALLJava_zqc_com_example_NativeTest_java2jniMethod1(JNIEnv *env, jobject instance, jboolean b, jint i,                                             jfloat f, jstring s_) { //在native层会把string转换成c/c++都特别熟悉的char*，由char*可以转string,wstring等等。 //在Java层String是对象，这里讲char*指针指向了该对象，在方法结束的时候记得要是否该指针引用 if (b == JNI_TRUE) {     LOGE(&quot;b is true&quot;); } else {     LOGE(&quot;b is false&quot;); } float nativi = i + f; LOGE(&quot;native i: %f&quot;, nativi); const char *s = env-&gt;GetStringUTFChars(s_, 0); LOGE(&quot;native string: %s&quot;, s); env-&gt;ReleaseStringUTFChars(s_, s);}</code></pre>在上面可以看到，Java层的基本类型方法都会经过jni进行转换，转换成相应的jni类型。其操作也很方便。Java的String类型需要注意下，一般是将jstring先转换为char<em>然后对char </em>进行操作。由于这获取了一个局部引用，一般在调用结束后需要释放该局部引用。</li></ol><h4 id="2-2-java向native传递数组类型"><a href="#2-2-java向native传递数组类型" class="headerlink" title="2.2 java向native传递数组类型"></a>2.2 java向native传递数组类型</h4><pre><code>    //向native传递数组类型    public native void java2jniMethod2(int[] as, String[] strs);</code></pre><p>对应的jni方法是：</p><pre><code>extern &quot;C&quot;JNIEXPORT void JNICALLJava_zqc_com_example_NativeTest_java2jniMethod2(JNIEnv *env, jobject instance, jintArray as_,                                                jobjectArray strs) {    //获取数组里面内容    jint *as = env-&gt;GetIntArrayElements(as_, NULL);    int result = 0, len = env-&gt;GetArrayLength(as_);    for (int i = 0; i &lt; len; ++i) {        result += as[i];    }    LOGE(&quot;intarray sum is %d&quot;, result);    env-&gt;ReleaseIntArrayElements(as_, as, 0);    //这里可以看出String[]对应的是jobjectArray    len = env-&gt;GetArrayLength(strs);    for (int i = 0; i &lt; len; ++i) {        jstring temp = (jstring) env-&gt;GetObjectArrayElement(strs, i);        const char *ctemp = env-&gt;GetStringUTFChars(temp, JNI_FALSE);        LOGE(&quot;第%d个：%s&quot;, i, ctemp);    }}</code></pre><p>其中函数： jsize GetArrayLength(jxxxarray array);用于获取数组的长度<br>在Java端调用代码如下：</p><pre><code>    NativeTest test = new NativeTest();    int a[] = new int[3];    for (int i=0;i&lt;a.length;i++) {        a[i] = i + 10;    }    String[] strs = new String[4];    for (int i=0;i&lt;strs.length;i++) {        strs[i] = &quot;我的值：&quot;+i;    }    test.java2jniMethod2(a,strs);</code></pre><h5 id="2-2-1-处理基本数据类型有以下几个相关函数："><a href="#2-2-1-处理基本数据类型有以下几个相关函数：" class="headerlink" title="2.2.1 处理基本数据类型有以下几个相关函数："></a>2.2.1 处理基本数据类型有以下几个相关函数：</h5><p>(1) GetXXXArrayElements(Array arr , jboolean* isCopide);<br>这类函数可以把Java基本类型的数组转换到C/C++中的数组，有两种处理方式，一种JNI_TRUE是拷贝一份传回本地代码，另一个是JNI_FALSE把指向Java数组的指针直接传回到本地代码中，处理完本地化的数组后，通过ReleaseXXXArrayElements来释放数组</p><p>(2) ReleaseXXXArrayElements(Array arr , * array , jint mode)<br>用这个函数可以选择将如何处理Java跟C++的数组，是提交，还是撤销等，内存释放还是不释放等mode可以取下面的值:<br>0 ：对Java的数组进行更新并释放C/C++的数组<br>JNI_COMMIT ：对Java的数组进行更新但是不释放C/C++的数组<br>JNI_ABORT：对Java的数组不进行更新,释放C/C++的数组</p><p>(3) GetPrimitiveArrayCritical(jarray arr , jboolean* isCopied);<br>在获得数组上的锁后将返回一个句柄给数组。如果没有建立任何锁，则isCopy被置为JNI_TRUE，否则置为NULL或JNI_FALSE：</p><p>(4) ReleasePrimitiveArrayCritical(jarray arr , void* array , jint mode);<br>释放从GetPrimitiveArrayCritical调用中返回的数组。也是JDK1.2出来的，为了增加直接传回指向Java数组的指针而加入的函数，同样的也会有同GetStringCritical的死锁的问题。mode取值如下：<br>0：从carray中复制值到数组中，并释放分配给carray的存储器<br>JNI_COMMIT：从carray中复制值到数组中，但是不释放分配给carray的存储器<br>JNI_ABORT：不从carray中复制值到数组中</p><p>(5) GetXXXArrayRegion(Array arr , jsize start , jsize len , * buffer);<br>在C/C++预先开辟一段内存，然后把Java基本类型的数组拷贝到这段内存中。用于一个数组子集的复制操作。参数start指定了从何处复制的起始索引，参数len则指定了从数组中复制到本机数组的多个位置数量。</p><p>(6) SetXXXArrayRegion(Array arr , jsize start , jsize len , const * buffer);<br>用来复制本机数组的一段内容回Java数组中。元素一般从本机数组起始处（索引为0）开始复制，但是只是从位置start开始将len个元素复制到Java数组中。</p><p>(7) Array NewXXXArray(jsize sz)<br>创建一个包含length个元素的Java数组。</p><h5 id="2-2-2-处理对象数组类型有以下几个相关函数："><a href="#2-2-2-处理对象数组类型有以下几个相关函数：" class="headerlink" title="2.2.2 处理对象数组类型有以下几个相关函数："></a>2.2.2 处理对象数组类型有以下几个相关函数：</h5><p>(1)  jobjectArray NewObjectArray(jsize length, jclass elementClass, jobject initialElement );<br>创建对象数组，创建一个长度为length，并且持有类型为elementClass的对象的对象数组，数组中的所有元素都被置为initialElement</p><p>(2)  jobject GetObjectArrayElement(jobjectArray array, jsize Index);<br>获取数组元素，通过Index指定的索引在array中获取一个对象，如果索引超出边界，会抛出一个IndexOutOfBoundsException</p><p>(3) void SetObjectArrayElement(jobjectArray array, jsize index,jobject value);<br>设置元素值。在array中通过index指定的索引处设置元素值为value，如果index超出边界，会抛出一个IndexOutOfBoundException。</p><h4 id="2-3-java向native传递自定义java对象"><a href="#2-3-java向native传递自定义java对象" class="headerlink" title="2.3  java向native传递自定义java对象"></a>2.3  java向native传递自定义java对象</h4><p>定义一个Java层方法：</p><pre><code class="java">package zqc.com.example;/** * Created by zhangqianchu on 2018/2/1. */class Person {    long id;    String name;    int age;    public long getId() {        return id;    }    public void setId(long id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public String toString() {        return &quot;Person{&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;}&#39;;    }}</code></pre><p>定义一个Java的native方法：</p><pre><code>    //Java向native传自定义类对象    public native void java2jniMethod3(Person person);</code></pre><p>在native层实现</p><pre><code>extern &quot;C&quot;JNIEXPORT void JNICALLJava_zqc_com_example_NativeTest_java2jniMethod3(JNIEnv *env, jobject instance, jobject person) {    jclass cls = env-&gt;FindClass(&quot;zqc/com/example/Person&quot;);    if (cls == 0) {        LOGE(&quot;find class fail&quot;);        return;    }    jmethodID mid_ID = env-&gt;GetMethodID(cls, &quot;setId&quot;, &quot;(J)V&quot;);    jmethodID mid_Name = env-&gt;GetMethodID(cls, &quot;setName&quot;, &quot;(Ljava/lang/String;)V&quot;);    jmethodID mid_Age = env-&gt;GetMethodID(cls, &quot;setAge&quot;, &quot;(I)V&quot;);    if (mid_ID &amp;&amp; mid_Name &amp;&amp; mid_Age) {        env-&gt;CallVoidMethod(person, mid_ID, 100L);        jstring name = env-&gt;NewStringUTF(&quot;Tianyu&quot;);        env-&gt;CallVoidMethod(person, mid_Name, name);        env-&gt;CallVoidMethod(person, mid_Age, 18);        return;    }}</code></pre><p>在Java端调用</p><pre><code>Person person = new Person();test.java2jniMethod3(person);Toast.makeText(this, person.toString(),Toast.LENGTH_SHORT).show();</code></pre><p>从Java端传对象实例给native时，到native端任何对象都变为jobject类型，如果要做对该对象实例的任何操作需先获取该对象的jfieldID ,jmethodID,然后通过env-&gt;CallXXXMethod来操作该对象的方法其中第一个参数是该对象的具体实例，其中env-&gt;CallStaticXXXMethod方法用来调用该类的静态方法，调用静态方法的时候就不用传具体的对象过去了。</p><h4 id="2-4-java向native传递List对象"><a href="#2-4-java向native传递List对象" class="headerlink" title="2.4 java向native传递List对象"></a>2.4 java向native传递List对象</h4><p>定义Java的native方法</p><pre><code>//Java向native传List对象public native void java2jniMethod4(List&lt;Person&gt;people);</code></pre><p>在native中实现具体方法：</p><pre><code>extern &quot;C&quot;JNIEXPORT void JNICALLJava_zqc_com_example_NativeTest_java2jniMethod4(JNIEnv *env, jobject instance, jobject people) {    //下面所有操作都得先判断是否为空。。。    jclass cls = env-&gt;GetObjectClass(people);    jclass pcls = env-&gt;FindClass(&quot;zqc/com/example/Person&quot;);    //jmethodID getNameMid = env-&gt;GetMethodID(pcls, &quot;getName&quot;, &quot;()Ljava/lang/String;&quot;);    jmethodID  setNameMid = env-&gt;GetMethodID(pcls, &quot;setName&quot;, &quot;(Ljava/lang/String;)V&quot;);    //获取List的get方法id    jmethodID getMid = env-&gt;GetMethodID(cls, &quot;get&quot;, &quot;(I)Ljava/lang/Object;&quot;);    //获取List的长度    jmethodID sizeMid = env-&gt;GetMethodID(cls, &quot;size&quot;, &quot;()I&quot;);    int len = env-&gt;CallIntMethod(people, sizeMid);    for (int i = 0; i &lt; len; ++i) {        //获取第i个元素        jobject  data = env-&gt;CallObjectMethod(people, getMid, i);        env-&gt;CallVoidMethod(data, setNameMid, env-&gt;NewStringUTF(&quot;全部随我native&quot;));    }}</code></pre><p><code> jclass cls = env-&gt;GetObjectClass(people);</code>这是获取一个对象实例相应的类的最好的办法。从上面可以看出List在传到native时也是变成了jobject，然后具体操作都得通过env-&gt;GetObjectClass先获取到该类，然后获取到该类的具体jmethodID，jfieldID来完成相应的操作。调用的方法也是env-&gt;CallXXXMethod()。<br>然后在Java端调用该native方法：</p><pre><code>    NativeTest test = new NativeTest();    List&lt;Person&gt; people = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; 3; i++) {        Person person1 = new Person();        person1.setName(&quot;我是Java层&quot;);        people.add(person1);    }    test.java2jniMethod4(people);    Iterator&lt;Person&gt; iterator = people.iterator();    while (iterator.hasNext()) {        Person person1 = iterator.next();        Log.e(&quot;myndk&quot;, person1.getName() + &quot;\n&quot;);    }</code></pre><p>在上面即可通过native将Person的name全部进行了更改。</p><p><b>上面</b>都是Java向native传参，基本用法都类似。基本数据类型有相应的对照表，对象类型的都转为jobject，对对象的操作都是先获取该对象jclass,jmethodID,jfielID后再对对象实例进行操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h3&gt;&lt;p&gt;有时候我写了个Java层的方法，希望native层也能够调用（尤其是一个实体类的get，set方法在native一般都会
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android NDK开发，JNI开发" scheme="http://yoursite.com/tags/Android-NDK%E5%BC%80%E5%8F%91%EF%BC%8CJNI%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Android NDK开发系列教程1：环境搭建及基本代码结构</title>
    <link href="http://yoursite.com/2018/02/01/Android-NDK%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B1%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%9F%BA%E6%9C%AC%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/02/01/Android-NDK开发系列教程1：环境搭建及基本代码结构/</id>
    <published>2018-02-01T13:50:54.000Z</published>
    <updated>2018-07-30T14:34:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Eclipse-NDK开发环境搭建"><a href="#1-Eclipse-NDK开发环境搭建" class="headerlink" title="1. Eclipse NDK开发环境搭建"></a>1. Eclipse NDK开发环境搭建</h3><p>在开发NDK之前，Java的SDK，Android的NDK，以及Eclipse的ADT工具都需要大家先安装好，在SDK早期版本中没有ndk相关文件，当最近的AndroidSDK中包含了ndk相关文件，所以下载NDK工具的麻烦事这里就没有了。唯一要注意的是需要配置下NDK的环境变量。这样可以方便进行编译。AndroidSDK主要文件夹参考如下：<br><img src="http://img.blog.csdn.net/20180201161034954?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="AndroidSDK目录结构"><br>这里讲Eclipse的配置就将下如何添加External Tool来快速生成.h文件以及快速进行ndk_build编译。</p><h4 id="1-1-配置快速生成-h头文件的命令"><a href="#1-1-配置快速生成-h头文件的命令" class="headerlink" title="1.1 配置快速生成.h头文件的命令"></a>1.1 配置快速生成.h头文件的命令</h4><ol><li>点击Eclipse上面的图标，打开External Tool Configurations。<br><img src="http://img.blog.csdn.net/20180201162000196?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li><li>然后打开如下界面，在如下界面中双击Program，在底下会生成一个New_configuration。<br><img src="http://img.blog.csdn.net/20180201162930719?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>然后按照图片上面的格式填写相应的参数。<br>Location填写javah.exe的位置：C:\Program Files\Java\jdk1.8.0_91\bin\javah.exe<br>Working Directory填写当前的工作目录：${workspace_loc:/MyTest/src}<br>Arguments填写相应的参数：<pre><code>-classpath ${workspace_loc:/MyTest/src/bin/classes} -d ${workspace_loc:/MyTest/jni} -jni com.scu.MyNDK</code></pre>之后在External Tool的地方就会生成一个JavaH的命令工具，点击即可生成对应的.h头文件了。这里要注意的是生成都文件前要先编译出.class文件。<br>其实这个和用javah.exe命令是一样的，具体命令如下：<br><img src="http://img.blog.csdn.net/20180201163500478?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><h3 id="2-Android-Studio的配置"><a href="#2-Android-Studio的配置" class="headerlink" title="2. Android Studio的配置"></a>2. Android Studio的配置</h3>AS太强大了，所有你想要的只需要简单的添加一个依赖，AS就会自动帮你下载，完全不用你去下载。最新的Android Studio在新建工程的时候，选中Include C++ Support后，即可进行NDK开发，这里注意下在AS中的编译换成了CMake工具，这个工具配置上稍微和Android.mk有些许不同。其配置文件在新建工程的CMakeLists.txt里面配置。</li></ol><p>在build.gradle里面也会自动配置cmake工具，配置如下：</p><pre><code class="xml">    externalNativeBuild {        cmake {            path &quot;CMakeLists.txt&quot;        }    }</code></pre><h3 id="3-基本代码结构"><a href="#3-基本代码结构" class="headerlink" title="3. 基本代码结构"></a>3. 基本代码结构</h3><p>利用AS创建工程后，工程会自动生成如下代码：</p><pre><code class="java">package zqc.com.example;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;public class MainActivity extends AppCompatActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);    }    // Used to load the &#39;native-lib&#39; library on application startup.    static {        System.loadLibrary(&quot;native-lib&quot;);    }    /**     * A native method that is implemented by the &#39;native-lib&#39; native library,     * which is packaged with this application.     */    public native String stringFromJNI();}</code></pre><p>其中在static静态代码块中会加载动态链接库。在一个方法前加上native关键字即表明该方法是一个jni方法，因而只有声明，没有实现，其具体实现在c/c++代码中。<br>找到cpp文件，打开后内容如下：</p><pre><code class="cpp">#include &lt;jni.h&gt;#include &lt;string&gt;extern &quot;C&quot;JNIEXPORT jstringJNICALLJava_zqc_com_example_MainActivity_stringFromJNI(        JNIEnv *env, jobject /* this */) {    std::string hello = &quot;Hello from C++&quot;;    return env-&gt;NewStringUTF(hello.c_str());}</code></pre><p>其中extern “C”表示在编译的时候导出为c语言的格式，JNIEXPORT表示该函数是可以导出的，可以由外部方法进行调用，这和dll类似，jstring表示返回值，JNICALL关键字表示这是一个jni方法，Java_zqc_com_example_MainActivity_stringFromJNI其中Java是固定格式，zqc_com_example_MainActivity是全类名，stringFromJNI是具体的方法名，具体参数：JNIEnv <em>env为env指针，调用jni的很多方法都需要该指针，jobject /</em> this */这个表示当前类的this指针，这里因为没用到就没有命名。<br>在以往开发中可能是把.h和.cpp分开了，这个是AS自动生成的，这里并没有单独生成.h文件。c/c++开发也有自己的结构，这里除了需要对外暴露接口的需要按照上面格式编写外，其他的都可以用古老的c/c++进行编写并遵循古老的结构。你可以先定义.h文件，然后在.cpp里面具体实现。<br>点击Build-&gt;Make Project（快捷键Ctrl+F9）即可生成动态链接库文件.so，其路径在：<br><img src="http://img.blog.csdn.net/20180201172808764?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>AS自动生成了Debug版和Release版，并且在各个版本中又生成了不同平台的.so文件。只能说这个AS太牛叉了~<br>之后运行工程，安装到手机上时就把对应的so也拷贝到了手机中了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>目前应该是绝大多数人都采用AndroidStudio进行开发，谷歌官方已经不再对Eclipse的ADT进行维护了。而AS是绝对强大的工具，当你选择Include C++ Support的时候，AS会将NDK开发的一切都下载下来。所以如果采用AS开发，那么你学NDK开发的话，只需要把Android开发需要安装的JDK，SDK，AS等工具安装好后，即可进行开发。这个系列教程我也采用AS进行讲解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Eclipse-NDK开发环境搭建&quot;&gt;&lt;a href=&quot;#1-Eclipse-NDK开发环境搭建&quot; class=&quot;headerlink&quot; title=&quot;1. Eclipse NDK开发环境搭建&quot;&gt;&lt;/a&gt;1. Eclipse NDK开发环境搭建&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android NDK开发，JNI开发" scheme="http://yoursite.com/tags/Android-NDK%E5%BC%80%E5%8F%91%EF%BC%8CJNI%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深度学习课程资源</title>
    <link href="http://yoursite.com/2018/01/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E8%B5%84%E6%BA%90/"/>
    <id>http://yoursite.com/2018/01/23/深度学习课程资源/</id>
    <published>2018-01-23T14:40:46.000Z</published>
    <updated>2018-07-30T14:34:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前，深度学习和深度强化学习已经在实践中得到了广泛的运用。资源型博客sky2learn整理了15个深度学习和深入强化学习相关的在线课程，其中包括它们在自然语言处理（NLP），计算机视觉和控制系统中的应用教程。</p><p>这些课程涵盖了神经网络，卷积神经网络，循环网络和其变体，训练深度网络的困难，无监督表示学习，深度信念网络，深玻尔兹曼机器，深度Q学习，价值函数估计和优化以及蒙特卡洛树搜索等多种算法的基础知识。</p><p>吴恩达：深度学习专项</p><p>这系列课程侧重于讲解深度学习的基础和在不同领域的运用方式，如医疗健康，自动驾驶，手语阅读，音乐生成和自然语言处理等。课程共包含五个子课程，有视频讲座。同时，课程用户将获得使用TensorFlow解决实际问题的实践经验。</p><p>链接：<a href="https://www.coursera.org/specializations/deep-learning" target="_blank" rel="noopener">https://www.coursera.org/specializations/deep-learning</a></p><p>CMU: 深度学习</p><p>该课程由苹果人工智能研究所主任Ruslan Salakhutdinov主导。课程首先讲解了一些例如前馈神经网络、反向传播、卷积模型等的基本知识。然后介绍深度学习中的要点，包括有向图和无向图模型，独立成分分析（ICA），稀疏编码，自动编码器，限制玻尔兹曼机（RBM），蒙特卡罗方法，深度信念网络，深度玻尔兹曼机和亥姆霍兹机。其他内容包括深度网络中的正则化和优化、序列建模和深度强化学习。</p><p>链接：<a href="http://www.cs.cmu.edu/~rsalakhu/10707/" target="_blank" rel="noopener">http://www.cs.cmu.edu/~rsalakhu/10707/</a></p><p>斯坦福大学：深度学习理论（Stat385）</p><p>本课程讨论深度学习理论方面的知识。有8次特邀嘉宾讲座，这些嘉宾是深度学习、计算神经科学和统计学方面的领军人物。您将有机会在深度学习中，针对当前的研究趋势，探索他们观点的多样性和跨学科性。这门课有视频讲座。</p><p>链接：<a href="https://stats385.github.io/" target="_blank" rel="noopener">https://stats385.github.io/</a></p><p>Yoshua Bengio: 深度学习</p><p>该课程由蒙特利尔大学主导。课程首先回顾了神经网络的基本知识，包括感知器，反向传播算法和梯度优化。然后介绍了神经网络、概率图形模型、深度网络和表示学习等前沿知识。</p><p>链接：<a href="https://ift6266h16.wordpress.com/" target="_blank" rel="noopener">https://ift6266h16.wordpress.com/</a></p><p>UC Berkeley: 深度强化学习</p><p>该课程包括强化学习的基本知识：Q-学习和策略梯度，同时还包含了高级模型学习和预测、提取、奖励学习以及高级深度强化学习，例如信赖域策略梯度方法、actor-critic方法、探索方法。本门课有视频讲座。</p><p>链接：<a href="http://rll.berkeley.edu/deeprlcourse/" target="_blank" rel="noopener">http://rll.berkeley.edu/deeprlcourse/</a></p><p>Yoshua Bengio: 深度学习与强化学习暑期学校</p><p>暑期学校是由Yoshua Bengio和他的同事们组织。课程包括了深度学习和强化学习两个方向，内容有两个领域的基本知识，研究趋势和最新发现。课程特别邀请这两个领域的主要学者和研究人员进行讲解。暑期学校有视频讲座。</p><p>链接：<a href="https://mila.quebec/en/cours/deep-learning-summer-school-2017/" target="_blank" rel="noopener">https://mila.quebec/en/cours/deep-learning-summer-school-2017/</a></p><p>Google &amp; Udacity: 深度学习</p><p>该课程由谷歌首席科学家Vincent Vanhoucke和Udacity的Arpan Chakraborty共同创立。课程内容包括深度学习、深层神经网络、卷积神经网络和针对文本和序列的深层模型。课程作业要求使用tensorflow。这门课有视频讲座。</p><p>链接：<a href="https://cn.udacity.com/course/deep-learning--ud730" target="_blank" rel="noopener">https://cn.udacity.com/course/deep-learning--ud730</a></p><p>斯坦福大学：基于深度学习的自然语言处理（CS224n）</p><p>该课程是2017年冬斯坦福大学 “cs224n：深度学习中的自然语言处理”课程的压缩版，也是斯坦福大学2018课程的延续版。课程讨论了如何将深度学习应用在自然语言处理中，自然语言处理中的问题以及在自然语言处理中使用深度学习的限制。讲师有Christopher Manning和Richard Socher。</p><p>链接：<br><a href="https://www.youtube.com/playlist?list=PL3FW7Lu3i5Jsnh1rnUwq_TcylNr7EkRe6" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PL3FW7Lu3i5Jsnh1rnUwq_TcylNr7EkRe6</a></p><p>牛津大学：自然语言处理中的深度学习</p><p>本课程涵盖深度学习的基本原理以及如何将其应用在自然语言处理中。用户将学习如何定义这个领域中的数学问题，以及获得使用CPU和GPU的实际编程的经验。讲师分别来自牛津大学、CMU、DeepMind和英伟达公司。 这门课程包括视频讲座。</p><p>链接：<a href="https://github.com/oxford-cs-deepnlp-2017/lectures" target="_blank" rel="noopener">https://github.com/oxford-cs-deepnlp-2017/lectures</a></p><p>李飞飞：视觉识别中的卷积神经网络（cs231n）</p><p>本课程将涵盖深度学习的基础知识，以及如何将深度学习技术应用于计算机视觉。学生将通过作业和最终项目获得如何训练和微调神经网络的实践经验。该课程主要使用Python语言。本课程包括视频讲座。</p><p>链接：<a href="http://cs231n.stanford.edu/" target="_blank" rel="noopener">http://cs231n.stanford.edu/</a></p><p>CMU: 深度强化学习与控制</p><p>本课程由苹果人工智能研究所主任Ruslan salakhutdinovat和CMU的Katerina Fragkiadaki主导。内容包括深度学习，强化学习，马尔可夫链决策过程（MDP），部分可观马尔可夫链决策过程（POMDPs），时序差分学习，Q学习，深度学习，深刻Q学习的基础知识。前沿话题包括最优化控制、轨道优化、层次强化学习和迁移学习。</p><p>链接：<a href="https://katefvision.github.io/" target="_blank" rel="noopener">https://katefvision.github.io/</a></p><p>CMU: 深度学习入门</p><p>本课程由苹果公司人工智能研究所主任Ruslan Salakhutdinov主导，对深度学习做了一个快速而深入的介绍。课程共分为四个一小时时长的视频讲座，涵盖了监督学习，无监督学习，以及深度学习中的模型评估和开放式的研究问题等内容。</p><p>链接：<a href="https://simons.berkeley.edu/talks/tutorial-deep-learning" target="_blank" rel="noopener">https://simons.berkeley.edu/talks/tutorial-deep-learning</a></p><p>RLDM: 深度强化学习入门</p><p>课程由DeepMind的David Silver主导，发表于第二届强化学习与决策多学科会议（RLDM）上。在这一个半小时的视频教程中，用户将了解深度学习，强化学习的基本原理，以及如何将深度学习和强化学习以各种方式结合：即深度价值函数，深度策略，和深度模型。此外，用户还能向顶级专家学习如何处理这些方法中的发散问题。</p><p>链接：<a href="http://videolectures.net/rldm2015_silver_reinforcement_learning/" target="_blank" rel="noopener">http://videolectures.net/rldm2015_silver_reinforcement_learning/</a></p><p>UC Berkeley: 深度强化学习入门</p><p>这是一个关于强化学习长达一小时的教程，配有视频讲座。用户将看到强化学习能有多厉害。</p><p>链接：<a href="https://simons.berkeley.edu/talks/pieter-abbeel-2017-3-28" target="_blank" rel="noopener">https://simons.berkeley.edu/talks/pieter-abbeel-2017-3-28</a></p><p>MLSS: 深度强化学习入门</p><p>课程由OpenAI公司的研究科学家John Schulman主导，包括4个1小时长的视频讲座，并带有针对实验室问题的练习。</p><p>链接：<br><a href="https://www.youtube.com/playlist?list=PLjKEIQlKCTZYN3CYBlj8r58SbNorobqcp" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLjKEIQlKCTZYN3CYBlj8r58SbNorobqcp</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前，深度学习和深度强化学习已经在实践中得到了广泛的运用。资源型博客sky2learn整理了15个深度学习和深入强化学习相关的在线课程，其中包括它们在自然语言处理（NLP），计算机视觉和控制系统中的应用教程。&lt;/p&gt;
&lt;p&gt;这些课程涵盖了神经网络，卷积神经网络，循环网络和其
      
    
    </summary>
    
      <category term="人工智能" scheme="http://yoursite.com/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="深度学习 吴恩达" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    
  </entry>
  
  <entry>
    <title>国内配置gradle</title>
    <link href="http://yoursite.com/2018/01/22/%E5%9B%BD%E5%86%85%E9%85%8D%E7%BD%AEgradle/"/>
    <id>http://yoursite.com/2018/01/22/国内配置gradle/</id>
    <published>2018-01-22T14:14:45.000Z</published>
    <updated>2018-07-30T14:34:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知zf是怎么想的，为何要把Google developer给q了，导致Android开发很痛苦，如果不fq，那么gradle里面库就没法下载，不过感谢阿里云，在国内搭建了一个国内的gradle仓库。下面就配置一下国内的gradle仓库</p><h3 id="1-单个项目配置"><a href="#1-单个项目配置" class="headerlink" title="1. 单个项目配置"></a>1. 单个项目配置</h3><p>用这种方式仅对单个项目生效，不会影响其他的项目</p><pre><code class="xml">buildscript {    repositories {        maven { url &#39;http://maven.aliyun.com/nexus/content/groups/public/&#39; }                maven{ url &#39;http://maven.aliyun.com/nexus/content/repositories/jcenter&#39;}    }    dependencies {        classpath &#39;com.android.tools.build:gradle:2.2.3&#39;        // NOTE: Do not place your application dependencies here; they belong        // in the individual module build.gradle files    }        }allprojects {    repositories {        maven { url &#39;http://maven.aliyun.com/nexus/content/groups/public/&#39; }        maven{ url &#39;http://maven.aliyun.com/nexus/content/repositories/jcenter&#39;}    }}</code></pre><h3 id="2-配置对所有项目生效"><a href="#2-配置对所有项目生效" class="headerlink" title="2. 配置对所有项目生效"></a>2. 配置对所有项目生效</h3><p>在USER_HOME/.gradle/下创建init.gradle文件，填入以下内容：</p><pre><code class="xml">allprojects{    repositories {        def ALIYUN_REPOSITORY_URL = &#39;http://maven.aliyun.com/nexus/content/groups/public&#39;        def ALIYUN_JCENTER_URL = &#39;http://maven.aliyun.com/nexus/content/repositories/jcenter&#39;        all { ArtifactRepository repo -&gt;            if(repo instanceof MavenArtifactRepository){                def url = repo.url.toString()                if (url.startsWith(&#39;https://repo1.maven.org/maven2&#39;)) {                    project.logger.lifecycle &quot;Repository ${repo.url} replaced by $ALIYUN_REPOSITORY_URL.&quot;                    remove repo                }                if (url.startsWith(&#39;https://jcenter.bintray.com/&#39;)) {                    project.logger.lifecycle &quot;Repository ${repo.url} replaced by $ALIYUN_JCENTER_URL.&quot;                    remove repo                }            }        }        maven {                url ALIYUN_REPOSITORY_URL            url ALIYUN_JCENTER_URL        }    }}</code></pre><p>这样新建项目时用的gradle仓库也是阿里云的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不知zf是怎么想的，为何要把Google developer给q了，导致Android开发很痛苦，如果不fq，那么gradle里面库就没法下载，不过感谢阿里云，在国内搭建了一个国内的gradle仓库。下面就配置一下国内的gradle仓库&lt;/p&gt;
&lt;h3 id=&quot;1-单个项目
      
    
    </summary>
    
      <category term="gradle" scheme="http://yoursite.com/categories/gradle/"/>
    
    
      <category term="gradle配置" scheme="http://yoursite.com/tags/gradle%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Android中onSaveInstanceState和onRestoreInstanceState讲解</title>
    <link href="http://yoursite.com/2018/01/19/Android%E4%B8%ADonSaveInstanceState%E5%92%8ConRestoreInstanceState%E8%AE%B2%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/01/19/Android中onSaveInstanceState和onRestoreInstanceState讲解/</id>
    <published>2018-01-19T10:21:47.000Z</published>
    <updated>2018-07-30T14:34:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Android系统中，有时系统可能因为系统资源不够而杀死(kill)某些Activity，在kill Activity之前会调用 onSaveInstanceState来保存一些状态信息(当然也可以保存其他信息)，当再次回到该Activity时，系统会调用onRestoreInstanceState来恢复数据。<br>     下面先讲一下onSaveInstance的调用时机，也就是会在什么情况下被调用。onSaveInstance不是Activity正常生命周期里面的函数。在Google API文档上是这样介绍的： Android calls onSaveInstanceState() before the activity becomesvulnerable to being destroyed by the system, but does not bother calling itwhen the instance is actually being destroyed by a user action (such aspressing the BACK key)。也就是当某个activity变得“容易”被系统销毁时，该activity的onSaveInstanceState就会被执行，除非该activity是被用户主动销毁的该方法不会调用，例如当用户按BACK键的时候。“容易”包含以下几种情况：<br>1、当用户按下HOME键时。当按下HOME键后，由于系统不知道用户会新开多少程序，因而这个Activity可能会由于系统资源不足而被系统kill，因为在onPause之后会调用onSaveInstance来保存数据。<br>2、长按HOME键，选择运行其他的程序时。分析同上。<br>3、按下电源按键（关闭屏幕显示）时。分析同上。<br>4、从activity A中启动一个新的activity时。分析同上。<br>5、屏幕方向切换时，例如从竖屏切换到横屏时。在屏幕切换之前，系统会销毁activity A，在屏幕切换之后系统又会自动地创建activity A，所以onSaveInstanceState一定会被执行。</p><p>一般调用方式如下：</p><pre><code class="java">@Override      protected void onSaveInstanceState(Bundle outState) {          // TODO Auto-generated method stub          //这里保存需要保存的数据          String string = edit.getText().toString();          outState.putString(&quot;test&quot;, string);          super.onSaveInstanceState(outState);      }</code></pre><p>系统kill进程是有个先后顺序的：在Google上是这样介绍的<a href="https://developer.android.com/reference/android/app/Activity.html#ProcessLifecycle" target="_blank" rel="noopener">ProcessLifecycle</a>,其解释如下：<br>一般系统杀死进程的顺序是：</p><p>　　Android系统会尽力保持应用的进程，但是有时为了给新的进程和更重要的进程回收一些内存空间，它会移除一些旧的进程。</p><p>　　为了决定哪些进程留下，哪些进程被杀死，系统根据在进程中在运行的组件及组件的状态，为每一个进程分配了一个优先级等级。</p><p>　　优先级最低的进程首先被杀死。</p><p>　　这个进程重要性的层次结构有<strong>五个等级</strong>，下面就列出这五种进程，按照重要性来排列，最重要的放在最前。 </p><ol><li>前台进程 Foreground process<br><strong>前台进程</strong>是用户当前做的事所必须的进程，如果满足下面各种情况中的一种，一个进程被认为是在前台：<br>1.1 进程持有一个正在与用户交互的Activity（Activity正处于onResume()的状态）。<br>1.2 进程持有一个Service，这个Service和用户正在交互的Activity绑定。<br>1.3 进程持有一个Service，这个Service是在前台运行的，即它调用了<code>**[startForeground()](http://developer.android.com/reference/android/app/Service.html#startForeground(int, android.app.Notification))**</code>。<br>1.4 进程持有一个Service，这个Service正在执行它的生命周期回调函数（<code>[onCreate()](http://developer.android.com/reference/android/app/Service.html#onCreate())</code>, <code>[onStart()](http://developer.android.com/reference/android/app/Service.html#onStart(android.content.Intent, int))</code>, or <code>[onDestroy()](http://developer.android.com/reference/android/app/Service.html#onDestroy())</code>）。<br>1.5 进程持有一个BroadcastReceiver，这个BroadcastReceiver正在执行它的 <code>[onReceive()](http://developer.android.com/reference/android/content/BroadcastReceiver.html#onReceive(android.content.Context, android.content.Intent))</code> 方法。<br>杀死前台进程需要用户交互，因为前台进程的优先级是最高的。</li></ol><p>2.可见进程 Visible process<br>　　如果一个进程不含有任何前台的组件，但是仍然影响着用户在屏幕上可以看到的内容，就是<strong>可见进程</strong>。<br>　　可见进程满足下列情况之一：<br>　　1.进程持有一个Activity，这个Activity不在前台，但是仍然被用户可见（处于<strong>onPause()</strong>调用后又没有调用<strong>onStop()</strong>的状态）。<br>　　这种情况发生在，比如，前台的activity打开了一个对话框，这样activity就会在其后可见。<br>　　2.进程持有一个Service，这个Service和一个可见的（或者前台的）Activity绑定。<br>　　可见的进程也被认为是很重要的，一般不会被销毁，除非是为了保证所有前台进程的运行而不得不杀死可见进程的时候。 </p><ol><li><p>服务进程 Service process<br>　　如果一个进程中运行着一个service，这个service是通过 <code>[startService()](http://developer.android.com/reference/android/content/Context.html#startService(android.content.Intent))</code> 开启的，并且不属于上面两种较高优先级的情况，这个进程就是一个<strong>服务进程</strong>。<br>　　尽管服务进程没有和用户可以看到的东西绑定，但是它们一般在做的事情是用户关心的，比如后台播放音乐，后台下载数据等。 </p></li><li><p>后台进程 Background process<br>　　如果进程不属于上面三种情况，但是进程持有一个用户不可见的activity（activity的<strong>onStop()</strong>被调用，但是<strong>onDestroy()</strong>没有调用的状态），就认为进程是一个<strong>后台进程</strong>。<br>　　后台进程不直接影响用户体验，系统会为了前台进程、可见进程、服务进程而任意杀死后台进程。<br>　　通常会有很多个后台进程存在，它们会被保存在一个<strong>LRU (least recently used)</strong>列表中，这样就可以确保用户最近使用的activity最后被销毁，即最先销毁时间最远的activity。 </p></li><li><p>空进程<br>　　如果一个进程不包含任何活跃的应用组件，则认为是<strong>空进程</strong>。<br>　　保存这种进程的唯一理由是为了缓存的需要，为了加快下次要启动这个进程中的组件时的启动时间。<br>　　系统为了平衡进程缓存和底层内核缓存的资源，经常会杀死空进程。 </p></li><li><p>相关说明<br>　　1.Android会尽可能地把进程放在高的优先级。<br>　　比如，一个进程拥有一个可见状态的activity和一个service，这个进程会被认为是可见进程，而不是服务进程。<br>　　2.一个进程的等级有可能会因为其他进程的依赖而提高，一个进程服务于另一个进程，则它的优先级不会比它服务的进程优先级低。<br>　　比如，A进程中的一个content provider向B进程中的一个客户提供服务，或A进程中的一个service被绑定在B进程中的一个组件上，则A进程的优先级<strong>至少</strong>和B进程的优先级一样高。<br>　　3.因为服务进程的优先级比后台进程的优先级高，所以对于一个需要启动一个长时间操作的activity来说，开启一个service比创建一个工作线程的方法更好，尤其是对于操作将很可能超出activity的持续时间时。<br>　　比如要上传一个图片文件，应该开启一个service来进行上传工作，这样在用户离开activity时工作仍在进行。使用service将会保证操作至少有服务进程的优先级。</p></li></ol><p>总而言之，onSaveInstanceState的调用遵循一个重要原则，即当系统“未经你许可”时销毁了你的activity，则onSaveInstanceState会被系统调用，这是系统的责任，因为它必须要提供一个机会让你保存你的数据。<br>onSaveInstanceState的调用是在onPause（）之后执行的，即：onPause（）—&gt;onSaveInstanceState()–&gt;onStop( );<br>至于onRestoreInstanceState方法，需要注意的是，onSaveInstanceState方法和onRestoreInstanceState方法“不一定”是成对的被调用的，onRestoreInstanceState被调用的前提是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行。onRestoreInstanceState的bundle参数会传递到onCreate方法中，你也可以选择在onCreate方法中做数据还原。<br>onRestoreInstanceState()在onStart() 和 onPostCreate(Bundle)之间调用。<br>一般调用方式如下：</p><pre><code>@Override    protected void onRestoreInstanceState(Bundle savedInstanceState) {        // TODO Auto-generated method stub        //在Activity因为系统额崩溃后，会调用该函数进行数据恢复，恢复的数据就是通过onSaveInstanceState保存的数据        super.onRestoreInstanceState(savedInstanceState);        if (savedInstanceState!=null) {            String test = savedInstanceState.getString(&quot;test&quot;);            if (test!=null) {                edit.setText(test);            }        }    }</code></pre><p>在新版的SDK中，也就是API大于21的版本中新增了如下两个函数：</p><pre><code>/**     * 系统重启后，数据恢复能力。需要api&gt;21     */    @Override    public void onSaveInstanceState(Bundle outState, PersistableBundle outPersistentState) {        // TODO Auto-generated method stub        //这里保存持久化数据，该函数会调用上面一个函数。因而第一个outState会通过上一个函数保存        String string = edit.getText().toString();        outPersistentState.putString(&quot;test&quot;, string);        super.onSaveInstanceState(outState, outPersistentState);    }/**      * 系统重启后，数据恢复能力。需要api&gt;21就      * 这个方法会调用onRestoreInstanceState(Bundle savedInstanceState)方法。      */      @Override      public void onRestoreInstanceState(Bundle savedInstanceState, PersistableBundle persistentState) {          // TODO Auto-generated method stub          //系统因而意外重启后会调用该方法进行数据恢复，这个需要在manifest.xml里面注册： android:persistableMode=&quot;persistAcrossReboots&quot;          super.onRestoreInstanceState(savedInstanceState, persistentState);          if (persistentState!=null) {              String test = persistentState.getString(&quot;test&quot;);              if (test!=null) {                  edit.setText(test);              }          }      }</code></pre><p>这两个函数主要是为了系统重启后的数据恢复，使用时需要在AndroidManifest.xml里面的activity中添加android:persistableMode=”persistAcrossReboots”属性。PersistableBundle和Bundle差不多，是以key-value的形式使用的。具体代码见如下工程。</p><p>工程源码：<a href="http://download.csdn.net/detail/hty1053240123/9585928" target="_blank" rel="noopener">onSaveInstance测试工程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Android系统中，有时系统可能因为系统资源不够而杀死(kill)某些Activity，在kill Activity之前会调用 onSaveInstanceState来保存一些状态信息(当然也可以保存其他信息)，当再次回到该Activity时，系统会调用onRestor
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="onSaveInstanceState" scheme="http://yoursite.com/tags/onSaveInstanceState/"/>
    
  </entry>
  
  <entry>
    <title>AppLinks使用详解</title>
    <link href="http://yoursite.com/2018/01/18/AppLinks%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/01/18/AppLinks使用详解/</id>
    <published>2018-01-18T08:58:44.000Z</published>
    <updated>2018-07-30T14:34:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>官方介绍<a href="https://developer.android.com/training/app-links/verify-site-associations.html#the-difference" target="_blank" rel="noopener">Android App Links</a>内容是：</p><pre><code>Android App Links are a special type of deep link that allow your website URLs to immediately open the corresponding content in your Android app (without requiring the user to select the app).To add Android App Links to your app, define intent filters that open your app content using HTTP URLs (as described in [Create Deep Links to App Content]), and verify that you own both your app and the website URLs (as described in this guide). If the system successfully verifies that you own the URLs, the system automatically routes those URL intents to your app.</code></pre><p>意思就是AppLinks是一个特殊的DeepLink，它可以让你的应用和你的网站URL进行绑定，这样当你在点击你网站链接的时候（非浏览器中）就能调起你的App，而不是出现选择界面，使用方法如下<br><a href="https://developer.android.com/training/app-links/deep-linking.html" target="_blank" rel="noopener">Create Deep Links to App Content</a><br>这种绑定不是在点击的时候才核对链接，下面会介绍在什么情况下核对这种绑定的。</p><h3 id="2-与DeepLink的区别"><a href="#2-与DeepLink的区别" class="headerlink" title="2. 与DeepLink的区别"></a>2. 与DeepLink的区别</h3><p>官方是这样介绍DeepLink的。</p><pre><code>A [deep link] is an intent filter that allows users to directly enter a specific activity in your Android app. Clicking one of these links might open a disambiguation dialog, which allows the user to select one of multiple apps (including yours) that can hande the given URL. For example, figure 1 shows the disambiguation dialog after the user clicks a map link, asking whether to open the link in Maps or Chrome.</code></pre><p><a href="https://developer.android.com/training/app-links/deep-linking.html" target="_blank" rel="noopener">Deeplink</a>是一个intent过滤器，他可以使用户直接进入某个Activity页面。但是有个不好的是当匹配到多个intent时就会弹一个让用户选择的框。官方给了下面一张图，而AppLinks就不会有这个弹框：<br><img src="https://upload-images.jianshu.io/upload_images/7170430-1a711d54789310a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" width="200" height="400" alt="The disambiguation dialog" align="center"><br>具体区别官方也列了以下：</p><table><thead><tr><th style="text-align:left">Item</th><th style="text-align:center">Deep links</th><th style="text-align:left">App links</th></tr></thead><tbody><tr><td style="text-align:left">Intent URL</td><td style="text-align:center">scheme    http, https, or a custom scheme</td><td style="text-align:left">Requires http or https</td></tr><tr><td style="text-align:left">Intent action</td><td style="text-align:center">Any action</td><td style="text-align:left">Requires android.intent.action.VIEW</td></tr><tr><td style="text-align:left">Intent category</td><td style="text-align:center">Any category</td><td style="text-align:left">Requires android.intent.category.BROWSABLE and android.intent.category.DEFAULT</td></tr><tr><td style="text-align:left">Link verification</td><td style="text-align:center">None</td><td style="text-align:left">Requires a Digital Asset Links file served on you website with HTTPS</td></tr><tr><td style="text-align:left">User experience</td><td style="text-align:center">May show a disambiguation dialog for the user to select which app to open the link</td><td style="text-align:left">No dialog; your app opens to handle your website links</td></tr><tr><td style="text-align:left">Compatibility</td><td style="text-align:center">All Android versions</td><td style="text-align:left">Android 6.0 and higher</td></tr></tbody></table><h3 id="3-使用步骤"><a href="#3-使用步骤" class="headerlink" title="3.使用步骤"></a>3.使用步骤</h3><p>官方给的步骤如下<a href="https://developer.android.com/training/app-links/index.html" target="_blank" rel="noopener">Handling Android App Links</a></p><h4 id="3-1-在manifest中开启autoVerify"><a href="#3-1-在manifest中开启autoVerify" class="headerlink" title="3.1 在manifest中开启autoVerify"></a>3.1 在manifest中开启autoVerify</h4><pre><code>&lt;activity ...&gt;    &lt;intent-filter android:autoVerify=&quot;true&quot;&gt;        &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;        &lt;data android:scheme=&quot;http&quot; android:host=&quot;www.example.com&quot; /&gt;        &lt;data android:scheme=&quot;https&quot; /&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;</code></pre><p>这里注意下，开启autoVerify的activity中的<intent-filter..>的action必须为android.intent.action.VIEW，category必须包含android.intent.category.BROWSABLE，data的scheme必须包含http/https,否则不生效，而且AppLinks必须在Android 6.0 以上的手机才可生效。验证包含以下几方面：</intent-filter..></p><ol><li>系统会检查包含以下几方面的所有intent-filter</li></ol><ul><li>Action: android.intent.action.VIEW</li><li>Categories: android.intent.category.BROWSABLE and android.intent.category.DEFAULT</li><li>Data scheme: http or https</li></ul><ol><li>原话是：For each unique host name found in the above intent filters, Android queries the corresponding websites for the Digital Asset Links file at <a href="https://hostname/.well-known/assetlinks.json.。翻译过来就是系统会读取网站的/.well-known/assetlinks.json文件，然后验证包名和签名是否包含在assetlinks.json文件中。" target="_blank" rel="noopener">https://hostname/.well-known/assetlinks.json.。翻译过来就是系统会读取网站的/.well-known/assetlinks.json文件，然后验证包名和签名是否包含在assetlinks.json文件中。</a></li></ol><p>当且仅当上面两个条件满足时才会形成绑定。</p><h4 id="3-2-支持多hosts的绑定。"><a href="#3-2-支持多hosts的绑定。" class="headerlink" title="3.2 支持多hosts的绑定。"></a>3.2 支持多hosts的绑定。</h4><pre><code class="xml">&lt;intent-filter&gt;  ...  &lt;data android:scheme=&quot;https&quot; android:host=&quot;www.example.com&quot; /&gt;  &lt;data android:scheme=&quot;app&quot; android:host=&quot;open.my.app&quot; /&gt;&lt;/intent-filter&gt;</code></pre><p>上面在同一个<intent-filter ..="">里面写的两个<data ..="">，他们除了组合<a href="https://www.example.com和app://open.my.app外app://www.example.com和" target="_blank" rel="noopener">https://www.example.com和app://open.my.app外app://www.example.com和</a> <a href="https://open.my.app也是满足上面的" target="_blank" rel="noopener">https://open.my.app也是满足上面的</a><intent-filter ..="">的。而分开写的时候，不存在上面的问题。</intent-filter></data></intent-filter></p><h4 id="3-3-在网站上创建assetlinks-json文件"><a href="#3-3-在网站上创建assetlinks-json文件" class="headerlink" title="3.3 在网站上创建assetlinks.json文件"></a>3.3 在网站上创建assetlinks.json文件</h4><p>具体格式如下：</p><pre><code>[{  &quot;relation&quot;: [&quot;delegate_permission/common.handle_all_urls&quot;],  &quot;target&quot;: {    &quot;namespace&quot;: &quot;android_app&quot;,    &quot;package_name&quot;: &quot;com.example&quot;,    &quot;sha256_cert_fingerprints&quot;:    [&quot;14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5&quot;]  }}]</code></pre><p>其中package_name就是应用的包名，sha256_cert_fingerprints为正式版的签名。上传时修改这两个属性值。如果一个应用对于多个网站时，可以配置多个对象，配置如下：</p><pre><code>[{  &quot;relation&quot;: [&quot;delegate_permission/common.handle_all_urls&quot;],  &quot;target&quot;: {    &quot;namespace&quot;: &quot;android_app&quot;,    &quot;package_name&quot;: &quot;com.example.puppies.app&quot;,    &quot;sha256_cert_fingerprints&quot;:    [&quot;14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5&quot;]  }  },  {  &quot;relation&quot;: [&quot;delegate_permission/common.handle_all_urls&quot;],  &quot;target&quot;: {    &quot;namespace&quot;: &quot;android_app&quot;,    &quot;package_name&quot;: &quot;com.example.monkeys.app&quot;,    &quot;sha256_cert_fingerprints&quot;:    [&quot;14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5&quot;]  }}]</code></pre><p>然后将该文件放在网站的.well-known目录下，放了之后要试试能不能用：</p><pre><code>https://domain.name/.well-known/assetlinks.json</code></pre><p>提交完后确定以下几个是否正确：</p><pre><code>Be sure of the following:*   The `assetlinks.json` file is served with content-type `application/json`.*   The `assetlinks.json` file must be accessible over an HTTPS connection, regardless of whether your app&#39;s intent filters declare HTTPS as the data scheme.*   The `assetlinks.json` file must be accessible without any redirects (no 301 or 302 redirects) and be accessible by bots (your `robots.txt` must allow crawling `/.well-known/assetlinks.json`).*   If your app links support multiple host domains, then you must publish the `assetlinks.json` file on each domain. See [Supporting app linking for multiple hosts](https://developer.android.com/training/app-links/verify-site-associations.html#multi-host).*   Do not publish your app with dev/test URLs in the manifest file that may not be accessible to the public (such as any that are accessible accessible only with a VPN). A work-around in such cases is to [configure build variants](https://developer.android.com/studio/build/build-variants.html) to generate a different manifest file for dev builds</code></pre><p>还有AppLinks仅支持https的网站。</p><h4 id="3-4-测试AppLinks"><a href="#3-4-测试AppLinks" class="headerlink" title="3.4 测试AppLinks"></a>3.4 测试AppLinks</h4><ol><li>测试json文件是否正确，请看 <a href="https://developers.google.com/digital-asset-links/tools/generator" target="_blank" rel="noopener">Statement List Generator and Tester</a><br>也可以采用以下链接进行验证：<pre><code>https://digitalassetlinks.googleapis.com/v1/statements:list?source.web.site=https://domain.name:optional_port&amp;relation=delegate_permission/common.handle_all_urls</code></pre></li><li>测试intent是否正确<br>可以使用adb进行测试，命令如下：<pre><code>adb shell am start -a android.intent.action.VIEW \ -c android.intent.category.BROWSABLE \ -d &quot;http://domain.name:optional_port&quot;</code></pre>下面命令测试已经存在的绑定：<pre><code>adb shell dumpsys package domain-preferred-apps</code></pre>上面命令等价于：<pre><code>adb shell dumpsys package d</code></pre>如果存在绑定的会显示如下结果：<pre><code>Package: com.android.vendingDomains: play.google.com market.android.comStatus: always : 200000002</code></pre>参数含义如下：<br>```</li></ol><ul><li>Package - Identifies an app by its package name, as declared in its manifest.</li><li>Domains - Shows the full list of hosts whose web links this app handles, using blank spaces as delimiters.</li><li>Status - Shows the current link-handling setting for this app. An app that has passed verification, and<br>whose manifest contains android:autoVerify=”true”, shows a status of always. The hexadecimal number after<br>this status is related to the Android system’s record of the user’s app linkage preferences. This value does<br>not indicate whether verification succeeded.<br>```</li></ul><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ol><li>优点：</li></ol><ul><li>不会弹选择框</li><li>可以直接通过url跳到对应的activity</li></ul><ol><li>缺点：</li></ol><ul><li>网站需要支持https</li><li>有个校验过程，步骤麻烦些。</li></ul><p>使用该机制可以直接绕过intent方式，直接通过url就能打开对应的界面。不过在设置中还是能关闭这个。目前支持该功能的应用和网站还是很少。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h3&gt;&lt;p&gt;官方介绍&lt;a href=&quot;https://developer.android.com/training/app-link
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="AppLinks, DeepLinks" scheme="http://yoursite.com/tags/AppLinks-DeepLinks/"/>
    
  </entry>
  
  <entry>
    <title>DeepLink用法及原理解析</title>
    <link href="http://yoursite.com/2018/01/18/DeepLink%E7%94%A8%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/01/18/DeepLink用法及原理解析/</id>
    <published>2018-01-18T04:34:20.000Z</published>
    <updated>2018-07-30T14:34:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p><a href="https://developer.android.com/training/app-links/deep-linking.html" target="_blank" rel="noopener">DeepLink</a>官网上有这样的解释：</p><pre><code>When a clicked link or programmatic request invokes a web URI intent, the Android system tries each of the following actions, in sequential order, until the request succeeds:1.  Open the user&#39;s preferred app that can handle the URI, if one is designated.2.  Open the only available app that can handle the URI.3.  Allow the user to select an app from a dialog.Follow the steps below to create and test links to your content. You can also use the [App Links Assistant](https://developer.android.com/studio/write/app-link-indexing.html) in Android Studio to add Android App Links</code></pre><p>翻译后的意思就是：<br>当单击链接或编程请求调用Web URI意图时，Android系统按顺序依次尝试以下每一个操作，直到请求成功为止：</p><ol><li>打开用户首选的应用程序，它可以处理URI，如果指定的话。</li><li>打开可以处理URI的惟一可用应用程序。</li><li>允许用户从对话框中选择应用程序。</li></ol><p>意思也就是用户可以自己写一串字符串，系统会对该字符串进行解析，然后调起注册过相应scheme的应用，如果有多个注册了，那么就会弹出对话框让用户选择。</p><h3 id="2-用法"><a href="#2-用法" class="headerlink" title="2. 用法"></a>2. 用法</h3><p>Google官方给了一个样例：<a href="https://github.com/google/search-samples" target="_blank" rel="noopener">search-samples</a><br>以下根据Android官方的<a href="https://developer.android.com/training/app-links/deep-linking.html#adding-filters" target="_blank" rel="noopener">deep-linking</a>的样例来说明如何使用。</p><pre><code>&lt;activity    android:name=&quot;com.example.android.GizmosActivity&quot;    android:label=&quot;@string/title_gizmos&quot; &gt;    &lt;intent-filter android:label=&quot;@string/filter_view_http_gizmos&quot;&gt;        &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;        &lt;!-- Accepts URIs that begin with &quot;http://www.example.com/gizmos” --&gt;        &lt;data android:scheme=&quot;http&quot;              android:host=&quot;www.example.com&quot;              android:pathPrefix=&quot;/gizmos&quot; /&gt;        &lt;!-- note that the leading &quot;/&quot; is required for pathPrefix--&gt;    &lt;/intent-filter&gt;    &lt;intent-filter android:label=&quot;@string/filter_view_example_gizmos&quot;&gt;        &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;        &lt;!-- Accepts URIs that begin with &quot;example://gizmos” --&gt;        &lt;data android:scheme=&quot;example&quot;              android:host=&quot;gizmos&quot; /&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;</code></pre><p>在上面有两个<intent-filter ..="">这两个<intent-filter ..="">只是在<data ..="">上有所区别，但是官方仍然建议我们分开写。比如：</data></intent-filter></intent-filter></p><pre><code class="xml">&lt;intent-filter&gt;  ...  &lt;data android:scheme=&quot;https&quot; android:host=&quot;www.example.com&quot; /&gt;  &lt;data android:scheme=&quot;app&quot; android:host=&quot;open.my.app&quot; /&gt;&lt;/intent-filter&gt;</code></pre><p>上面在同一个<intent-filter ..="">里面写的两个<data ..="">，他们除了组合<a href="https://www.example.com和app://open.my.app外app://www.example.com和" target="_blank" rel="noopener">https://www.example.com和app://open.my.app外app://www.example.com和</a> <a href="https://open.my.app也是满足上面的" target="_blank" rel="noopener">https://open.my.app也是满足上面的</a><intent-filter ..="">的。而分开写的时候，不存在上面的问题。<br>当你添加了上面的<intent-filter..>当你的Activity上面时，其他App，就可以通过一个intent去调起你的应用，官方这样说到：<br> Once you’ve added intent filters with URIs for activity content to your app manifest, Android is able to route any <a href="https://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="noopener">Intent</a> that has matching URIs to your app at runtime.<br>当注册了<intent-filter..>后，便可以在Activity的中获取其他应用传过来的intent值，具体调用如下：</intent-filter..></intent-filter..></intent-filter></data></intent-filter></p><pre><code>@Overridepublic void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.main);    Intent intent = getIntent();    String action = intent.getAction();    Uri data = intent.getData();}</code></pre><p>getIntent可以在Activity的生命周期的任何时段进行获取，不过一般别人应用要调你应用，肯定都是希望进入你的应用某个界面，或实现某个功能。其他应用会把该传的信息都传给你，最好的解析地方肯定是onCreate（或onStart但onStart还是会晚一些）。对于这个官方给了以下建议：</p><pre><code>*   The deep link should take users directly to the content, without any prompts, interstitial pages, or logins. Make sure that users can see the app content even if they never previously opened the application. It is okay to prompt users on subsequent interactions or when they open the app from the Launcher. This is the same principle as the [first click free](https://support.google.com/webmasters/answer/74536?hl=en) experience for web sites.*   Follow the design guidance described in [Navigation with Back and Up](https://developer.android.com/design/patterns/navigation.html) so that your app matches users&#39; expectations for backward navigation after they enter your app through a deep link</code></pre><p>意思就是：</p><ol><li>打开应用后应该直接到内容，不要有任何提示，间接的页面，或登录。确保用户可以看到应用程序的内容，即使他们以前从未打开过应用程序。可以在随后的交互中提示用户，或者在启动程序中打开应用程序。这与网站第一次点击免费体验的原理是相同的。</li><li>遵循导航与后退和向上描述的设计指南，使您的应用程序与用户通过向后链接进入您的应用程序的深度导航的期望相符。</li></ol><p>实现上面代码后就可以进行测试了。在测试时可以使用adb的shell命令进行测试，语法格式如下：</p><pre><code>$ adb shell am start        -W -a android.intent.action.VIEW        -d &lt;URI&gt; &lt;PACKAGE&gt;</code></pre><p>例如我们上面的例子就可以采用如下方式进行打开：</p><pre><code>$ adb shell am start        -W -a android.intent.action.VIEW        -d &quot;example://gizmos&quot; com.example.android</code></pre><p>上面的intent也可以通过浏览器里面的网页进行设置，现在浏览器都会解析这个intent然后调起对应的应用，即可以直接在网页中调起应用。</p><p>DeepLink使得开发网站和自己的App能很好的相互交互。而且一个intent字符串也好发送，比如你想推广你的App，你就可以把这个intent发给广告商，然后点击的时候就把这个intent给手机浏览器，通过浏览器调起你自己的应用。这个最好的应用还在搜索上，在搜索的时候，当用户搜到对应内容的时候，现在一般都是跳网站。但是如果有DeepLink，那么就可以直接通过DeepLink的intent直接跳转到你自己的App，这既方便了用户，也方便了开发者。</p><h3 id="3-DeepLink原理分析"><a href="#3-DeepLink原理分析" class="headerlink" title="3. DeepLink原理分析"></a>3. DeepLink原理分析</h3><h4 id="3-1-DeepLinkDispatch框架"><a href="#3-1-DeepLinkDispatch框架" class="headerlink" title="3.1 DeepLinkDispatch框架"></a>3.1 DeepLinkDispatch框架</h4><p><a href="https://github.com/airbnb/DeepLinkDispatch" target="_blank" rel="noopener">DeepLinkDispatch</a>是Airbnb推出的一个以注解形式来实现dispatch跳转的框架。这个它的简单介绍<a href="https://github.com/airbnb/DeepLinkDispatch/blob/master/README.md" target="_blank" rel="noopener">README.md</a>。</p><h4 id="3-2-Dispatch框架使用例子"><a href="#3-2-Dispatch框架使用例子" class="headerlink" title="3.2 Dispatch框架使用例子"></a>3.2 Dispatch框架使用例子</h4><pre><code>@DeepLink(&quot;foo://example.com/deepLink/{id}&quot;)public class MainActivity extends Activity {  @Override protected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    Intent intent = getIntent();    if (intent.getBooleanExtra(DeepLink.IS_DEEP_LINK, false)) {      Bundle parameters = intent.getExtras();      String idString = parameters.getString(&quot;id&quot;);      // Do something with idString    }  }}</code></pre><p>多个<intent-filter..>的注解</intent-filter..></p><pre><code>//多filter的注解@DeepLink({&quot;foo://example.com/deepLink/{id}&quot;, &quot;foo://example.com/anotherDeepLink&quot;})public class MainActivity extends Activity {  @Override protected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    Intent intent = getIntent();    if (intent.getBooleanExtra(DeepLink.IS_DEEP_LINK, false)) {      Bundle parameters = intent.getExtras();      String idString = parameters.getString(&quot;id&quot;);      // Do something with idString    }  }}</code></pre><p>某个方法的注解：</p><pre><code>@DeepLink(&quot;foo://example.com/methodDeepLink/{param1}&quot;)public static Intent intentForDeepLinkMethod(Context context, Bundle extras) {  Uri.Builder uri = Uri.parse(extras.getString(DeepLink.URI)).buildUpon();  return new Intent(context, MainActivity.class)      .setData(uri.appendQueryParameter(&quot;bar&quot;, &quot;baz&quot;).build())      .setAction(ACTION_DEEP_LINK_METHOD);}</code></pre><p>上面的注解相当于DeepLink中在manifest中的Activity标签下注册的<intent-filter..>，在DeepLinkDispatch中还可以注册一个广播接收者来接收分发的DeepLink字符串。</intent-filter..></p><pre><code>public class DeepLinkReceiver extends BroadcastReceiver {  private static final String TAG = &quot;DeepLinkReceiver&quot;;  @Override public void onReceive(Context context, Intent intent) {    String deepLinkUri = intent.getStringExtra(DeepLinkHandler.EXTRA_URI);    if (intent.getBooleanExtra(DeepLinkHandler.EXTRA_SUCCESSFUL, false)) {      Log.i(TAG, &quot;Success deep linking: &quot; + deepLinkUri);    } else {      String errorMessage = intent.getStringExtra(DeepLinkHandler.EXTRA_ERROR_MESSAGE);      Log.e(TAG, &quot;Error deep linking: &quot; + deepLinkUri + &quot; with error message +&quot; + errorMessage);    }  }}public class YourApplication extends Application {  @Override public void onCreate() {    super.onCreate();    IntentFilter intentFilter = new IntentFilter(DeepLinkHandler.ACTION);//使用应用内广播注册的，不用担心其他应用收到LocalBroadcastManager.getInstance(this).registerReceiver(new DeepLinkReceiver(), intentFilter);  }}</code></pre><p>下面就来分析下它的原理。</p><h4 id="3-3-源码剖析"><a href="#3-3-源码剖析" class="headerlink" title="3.3 源码剖析"></a>3.3 源码剖析</h4><h5 id="3-3-1-根据注解生成对应class文件"><a href="#3-3-1-根据注解生成对应class文件" class="headerlink" title="3.3.1 根据注解生成对应class文件"></a>3.3.1 根据注解生成对应class文件</h5><p>在AS点击build后即可生成对应的class文件，主要的文件有以下几个：<br><img src="http://upload-images.jianshu.io/upload_images/7170430-e37d53735359d7a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="class.png"><br>在DeepLinkDispatch框架中主要是通过DeepLinkDelegate代理来处理传来的Uri，在DeepLinkDelegate中主要是dispatchFrom这个方法来处理Uri。代码如下：<br><img src="http://upload-images.jianshu.io/upload_images/7170430-529f9c694ffff441.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DeepLinkResult.png"></p><ol><li>收下根据getIntent.getData()即可获取到对应的uri。</li><li><p>然后通过DeepLinkLoader.load()来加载注册的uri。代码如下<br><img src="http://upload-images.jianshu.io/upload_images/7170430-d0a721dddf62777d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="load.png"></p></li><li><p>调用loader.parseUri去解析Uri，解析完成后返回的是DeepLinkEntry来供我们使用。</p></li><li><p>解析Uri中的key-value对，代码仍然在dispatchFrom中。<br><img src="http://upload-images.jianshu.io/upload_images/7170430-bde2577d977326c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="parseUri.png"></p></li></ol><p>其中DeepLinkUri.getParameters代码如下：<br><img src="http://upload-images.jianshu.io/upload_images/7170430-6ce444ecbe3230d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="getParameters.png"></p><p>然后调用了该类的parseParameters获取patterns集合。<br><img src="http://upload-images.jianshu.io/upload_images/7170430-db42ed45c5c28d6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="parseParameters.png"></p><p>从DeepLink的intent中获取的就是key，具体跳转的内容就是value。</p><ol><li>DeepLinkUri.queryParameterNames<br>通过queryParameterNames就把真实的Uri解析成对应的注解了，之后就会进行分发逻辑了。</li><li>具体分发逻辑<br><img src="http://upload-images.jianshu.io/upload_images/7170430-96ae9b6d76b7a703.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dispatch.png"><br><img src="http://upload-images.jianshu.io/upload_images/7170430-e312d85d0fccc231.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dispatch1.png"><br>6.1 首先生成Intent对象<br>6.2 setAction和data，通过以上将action和data放入Intent中。<br>6.3 处理Bundle。<br>6.4 调用callingActivity。<br>6.5 startActivity<br>6.6 createResultAndNotify</li></ol><p>通过以上步骤就完成了DeepLink调起应用页面的操作了，具体代码稍后再贴。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ol><li>DeepLink实现了网页直接和App直接跳转。之前手机上的每个App都相当于一个个孤岛，没有办法和广泛的网站实现直接的跳转。现在比如你在浏览微博的时候看到某个App上面有精彩的内容，你就可以直接点击链接跳转到App里面（甚至可以判断如果按照了App就进入App里面，如果不安装那么就进入应用市场的该App下载界面），这样的交互很方便，很好的将App连接到了整个网络世界，以后有个浏览器就能随意的跳转。</li><li>DeepLink完全可以在搜索中使用，目前的搜索都是搜到了内容还是调网页。以后如果开发者把自己的DeepLink链接提交给搜索公司，那么在搜索到对应的结果的时候就可以直接点击搜到的结果跳转到自己的App了。这个还能应用到广告上去。推广自己的App就更容易了。</li><li>DeepLink使得大企业的众多App之间相互拉活，相互跳转。假如某公司有个超级App，那么想推广自己的其他App就可以使用DeepLink在开启自己某个子页面的时候，把这个子页面交给其他App进行处理。这样就拉活了自己的其他App了。</li><li>在DeepLink的基础上，Google又新出了一个AppLinks，AppLinks就是你自己的网站和你自己的App相互关联了。比如用户在短信中点击了你的网站，那么就可以直接跳转到你的App，而不会出现选择对话框。Google官方是这样说的：<br>```<br>Android App Links are a special type of deep link that allow your website URLs to immediately open the<br>corresponding content in your Android app (without requiring the user to select the app).</li></ol><p>To add Android App Links to your app, define intent filters that open your app content using HTTP URLs (as<br> described in [Create Deep Links to App Content]), and verify that you own both your app and the website URLs (as described in this guide). If the<br>system successfully verifies that you own the URLs, the system automatically routes those URL intents to your app.<br>```<br>创建你自己的AppLinks，可以参考如下<a href="https://developer.android.com/training/app-links/deep-linking.html" target="_blank" rel="noopener">Create Deep Links to App Content</a>。后续我会专门写篇文章介绍下AppLinks及其用法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://developer.android.com/training/app-links/de
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android DeepLink 源码解析" scheme="http://yoursite.com/tags/Android-DeepLink-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Android应用内部广播机制详解</title>
    <link href="http://yoursite.com/2018/01/17/Android%E5%BA%94%E7%94%A8%E5%86%85%E9%83%A8%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/01/17/Android应用内部广播机制详解/</id>
    <published>2018-01-17T10:07:47.000Z</published>
    <updated>2018-07-30T14:34:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>通常我们在使用Android广播的时候都会直接将广播注册到系统的AMS当中，由于AMS任务繁忙，一般可能不会立即能处理到我们发出的广播，如果我们使用广播是在应用内的单个进程中使用，则完全可以采用LocalBroadcastManager来处理。LocalBroadcastManager采用的是Handler的消息机制来处理的广播，而注册到系统中的是通过Binder机制实现的，速度是应用内广播要慢很多。不过由于Handler的消息机制是为了同一个进程的多线程间进行通信的，因而跨进程时无法使用应用内广播。应用内广播onReceive也是在主线程中被回调执行。</p><h4 id="1-1-使用"><a href="#1-1-使用" class="headerlink" title="1.1 使用"></a>1.1 使用</h4><p>在使用上和普通的Broadcast类似，主要分5步。具体如下：</p><pre><code class="java">//1. 自定义广播接收者public class LocalReceiver extends BroadcastReceiver {    public void onReceive(Context context, Intent intent) {        ...    }}LocalReceiver localReceiver = new LocalReceiver();//2. 注册广播LocalBroadcastManager.getInstance(context)             .registerReceiver(localReceiver, new IntentFilter(“test”));//4. 发送广播LocalBroadcastManager.getInstance(context).sendBroadcast(new Intent(&quot;test&quot;));//5. 取消注册广播LocalBroadcastManager.getInstance(context).unregisterReceiver(localReceiver);</code></pre><p>自定义广播和普通的广播一样，在注册广播的时候将该广播接受者注册到LocalBroadcatManager中。当发生时也是调用LocalBroadcastManager的sendBroadcast进行发生。同样在不使用时记得取消广播注册。</p><h3 id="2-LocalBroadcastManager"><a href="#2-LocalBroadcastManager" class="headerlink" title="2. LocalBroadcastManager"></a>2. LocalBroadcastManager</h3><h4 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h4><p>LocalBroadcastManager采用的是单例模式，其构造函数是私有的，获取该类实例的方法是getInstance，具体代码如下：</p><pre><code class="java">  private final Handler mHandler;    private static final Object mLock = new Object();    private static LocalBroadcastManager mInstance;    public static LocalBroadcastManager getInstance(Context context) {        synchronized (mLock) {            if (mInstance == null) {                mInstance = new LocalBroadcastManager(context.getApplicationContext());            }            return mInstance;        }    }    private LocalBroadcastManager(Context context) {        mAppContext = context;        //mHandler是主线程的        mHandler = new Handler(context.getMainLooper()) {            @Override            public void handleMessage(Message msg) {                switch (msg.what) {                    case MSG_EXEC_PENDING_BROADCASTS:                        executePendingBroadcasts();//这里去执行广播分发                        break;                    default:                        super.handleMessage(msg);                }            }        };    }</code></pre><p>在构造函数中创建了一个mHandler，该mHandler关联的是主线程的Looper。即消息处理时都在主线程中处理。</p><h4 id="2-2-registerReceiver"><a href="#2-2-registerReceiver" class="headerlink" title="2.2 registerReceiver"></a>2.2 registerReceiver</h4><pre><code class="java">public void registerReceiver(BroadcastReceiver receiver, IntentFilter filter) {        //在注册，取消注册，发送广播的时候都需要先获取mReceivers的锁        synchronized (mReceivers) {            //新建一个ReceiverRecord实体表示该receiver及对应的filter            ReceiverRecord entry = new ReceiverRecord(filter, receiver);            //获取receiver对应的filters            ArrayList&lt;IntentFilter&gt; filters = mReceivers.get(receiver);            if (filters == null) {                //如果该receiver没有对应的filters则，新建一个。                filters = new ArrayList&lt;IntentFilter&gt;(1);                mReceivers.put(receiver, filters);            }            //将filter放入该receiver对应的filters中            filters.add(filter);            for (int i=0; i&lt;filter.countActions(); i++) {                String action = filter.getAction(i);                ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(action);                if (entries == null) {                    entries = new ArrayList&lt;ReceiverRecord&gt;(1);                    //将action放入mActions中                    mActions.put(action, entries);                }                entries.add(entry);            }        }    }</code></pre><p>注册的时候也就是将receiver自己和对应的filter及action放入到mReceivers和mActions当中。代码比较简单。</p><h4 id="2-3-发送广播sendBroadcast"><a href="#2-3-发送广播sendBroadcast" class="headerlink" title="2.3 发送广播sendBroadcast"></a>2.3 发送广播sendBroadcast</h4><pre><code class="java">public boolean sendBroadcast(Intent intent) {        synchronized (mReceivers) {            final String action = intent.getAction();            final String type = intent.resolveTypeIfNeeded(                    mAppContext.getContentResolver());            final Uri data = intent.getData();            final String scheme = intent.getScheme();            final Set&lt;String&gt; categories = intent.getCategories();            final boolean debug = DEBUG ||                    ((intent.getFlags() &amp; Intent.FLAG_DEBUG_LOG_RESOLUTION) != 0);            if (debug) Log.v(                    TAG, &quot;Resolving type &quot; + type + &quot; scheme &quot; + scheme                    + &quot; of intent &quot; + intent);            ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(intent.getAction());            if (entries != null) {                if (debug) Log.v(TAG, &quot;Action list: &quot; + entries);                ArrayList&lt;ReceiverRecord&gt; receivers = null;                for (int i=0; i&lt;entries.size(); i++) {                    ReceiverRecord receiver = entries.get(i);                    if (debug) Log.v(TAG, &quot;Matching against filter &quot; + receiver.filter);                    if (receiver.broadcasting) {                        if (debug) {                            Log.v(TAG, &quot;  Filter&#39;s target already added&quot;);                        }                        continue;                    }                    int match = receiver.filter.match(action, type, scheme, data,                            categories, &quot;LocalBroadcastManager&quot;);                    if (match &gt;= 0) {                        if (debug) Log.v(TAG, &quot;  Filter matched!  match=0x&quot; +                                Integer.toHexString(match));                        if (receivers == null) {                            receivers = new ArrayList&lt;ReceiverRecord&gt;();                        }                        receivers.add(receiver);                        receiver.broadcasting = true;                    } else {                        if (debug) {                            String reason;                            switch (match) {                                case IntentFilter.NO_MATCH_ACTION: reason = &quot;action&quot;; break;                                case IntentFilter.NO_MATCH_CATEGORY: reason = &quot;category&quot;; break;                                case IntentFilter.NO_MATCH_DATA: reason = &quot;data&quot;; break;                                case IntentFilter.NO_MATCH_TYPE: reason = &quot;type&quot;; break;                                default: reason = &quot;unknown reason&quot;; break;                            }                            Log.v(TAG, &quot;  Filter did not match: &quot; + reason);                        }                    }                }                if (receivers != null) {                    for (int i=0; i&lt;receivers.size(); i++) {                        receivers.get(i).broadcasting = false;                    }                    mPendingBroadcasts.add(new BroadcastRecord(intent, receivers));                    if (!mHandler.hasMessages(MSG_EXEC_PENDING_BROADCASTS)) {                        mHandler.sendEmptyMessage(MSG_EXEC_PENDING_BROADCASTS);                    }                    return true;                }            }        }        return false;    }</code></pre><p>主要步骤：1.根据Intent的action来查询相应的广播接收者列表；<br>2.创建相应广播，添加到mPendingBroadcasts队列；<br>3.发送MSG_EXEC_PENDING_BROADCASTS消息。将消息传给主线程进行处理。<br>4.主线程mHandler接受到后就由该类的handlerMessage进行处理。在该方法中调用executePendingBroadcasts()进行处理</p><pre><code class="java">    private void executePendingBroadcasts() {        while (true) {            BroadcastRecord[] brs = null;            synchronized (mReceivers) {//注意多线程下的同步                final int N = mPendingBroadcasts.size();                if (N &lt;= 0) {                    return;                }                brs = new BroadcastRecord[N];                mPendingBroadcasts.toArray(brs);//把待处理的广播转成数组形式                mPendingBroadcasts.clear();//然后就可以把mPendingBroadcasts清空            }            //for循环变量每个接受者，然后调用对应的onReceive            for (int i=0; i&lt;brs.length; i++) {                BroadcastRecord br = brs[i];                for (int j=0; j&lt;br.receivers.size(); j++) {                    br.receivers.get(j).receiver.onReceive(mAppContext, br.intent);                }            }        }    }</code></pre><p>处理也很简单，查询相应的变量，找到有多少个接受者，然后调用接受者的onReceive，该调用在主线程中，因而不要做耗时操作。在LocalBroadcastManager中还提供了同步发送广播处理的方法：</p><pre><code class="java">    //使用该方法会立即去让接受者处理广播。    public void sendBroadcastSync(Intent intent) {        if (sendBroadcast(intent)) {            executePendingBroadcasts();        }    }</code></pre><h4 id="2-4-广播的注销"><a href="#2-4-广播的注销" class="headerlink" title="2.4 广播的注销"></a>2.4 广播的注销</h4><pre><code class="java"> public void unregisterReceiver(BroadcastReceiver receiver) {        synchronized (mReceivers) {            ArrayList&lt;IntentFilter&gt; filters = mReceivers.remove(receiver);            if (filters == null) {                return;            }            for (int i=0; i&lt;filters.size(); i++) {                IntentFilter filter = filters.get(i);                for (int j=0; j&lt;filter.countActions(); j++) {                    String action = filter.getAction(j);                    ArrayList&lt;ReceiverRecord&gt; receivers = mActions.get(action);                    if (receivers != null) {                        for (int k=0; k&lt;receivers.size(); k++) {                            if (receivers.get(k).receiver == receiver) {                                receivers.remove(k);                                k--;                            }                        }                        if (receivers.size() &lt;= 0) {                            mActions.remove(action);                        }                    }                }            }        }    }</code></pre><p>注销广播也很简单，找到注册时候添加到List中的变量，然后remove掉。注意要讲mReceivers,mActions里面保存的都remove了。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>和普通广播比，应用内广播安全，速度快。缺点是只能在应用的一个进程中使用，不能跨进程使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h3&gt;&lt;p&gt;通常我们在使用Android广播的时候都会直接将广播注册到系统的AMS当中，由于AMS任务繁忙，一般可能不会立即能处理到
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="应用内部广播,LocalBroadcastManager" scheme="http://yoursite.com/tags/%E5%BA%94%E7%94%A8%E5%86%85%E9%83%A8%E5%B9%BF%E6%92%AD-LocalBroadcastManager/"/>
    
  </entry>
  
  <entry>
    <title>SharedPreferences源码详解</title>
    <link href="http://yoursite.com/2018/01/17/SharedPreferences%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/01/17/SharedPreferences源码详解/</id>
    <published>2018-01-17T03:59:33.000Z</published>
    <updated>2018-07-30T14:34:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>写这篇博客目的在于巩固自己对SharedPreferences的理解。SharePreferences是Android系统提供的轻量级数据存储方案，主要基于键值对方式保存数据，真实的数据是保存在/data/data/packageName/shared_pref/目录下面的。可以保存多种数据到该文件中，以下是一个简单的Sharepreference文件。</p><pre><code class="xml">&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39; standalone=&#39;yes&#39; ?&gt;&lt;map&gt;    &lt;boolean name=&quot;btest&quot; value=&quot;true&quot; /&gt;    &lt;string name=&quot;stest&quot;&gt;string&lt;/string&gt;    &lt;int name=&quot;itest&quot; value=&quot;999&quot; /&gt;    &lt;long name=&quot;ltest&quot; value=&quot;1516358782&quot; /&gt;    &lt;int name=&quot;itest_1&quot; value=&quot;2&quot; /&gt;&lt;/map&gt;</code></pre><p>从文件中可以看出就是采用简单xml方式进行保存的。</p><h4 id="1-1使用实例"><a href="#1-1使用实例" class="headerlink" title="1.1使用实例"></a>1.1使用实例</h4><pre><code>SharedPreferences preferences = context.getSharedPreferences(&quot;share&quot;, Context.MODE_PRIVATE);SharedPreferences.Editor editor = preferences.edit();editor.putBoolean(&quot;btest&quot;, true);editor.putString(&quot;stest&quot;, &quot;string test&quot;);//editor.apply();//异步保存editor.commit();//同步保存</code></pre><h4 id="1-2基本结构"><a href="#1-2基本结构" class="headerlink" title="1.2基本结构"></a>1.2基本结构</h4><p>这里借用Gityuan博客中的类继承图<br><img src="https://s1.ax1x.com/2018/01/17/pDZT58.jpg" alt="Sharepreference架构图"><br>在Sharepreference中，Sharepreference和Editor只是两个接口，在这两个接口中定义了一个普通的键值对存储的数据一些常用的操作。然后具体你想把这键值对存哪，你可以自己定义相应的文件或数据库，甚至你可以写个保存到网络中去。在Android系统中给出的是采用xml方式存在xml的文件中，具体实现类是SharepreferenceImpl和SharepreferenceImpl.EditorImpl。同时在ContextImpl中有Sharepreference的对应内存中的数据。</p><h3 id="2-Sharepreference源码分析"><a href="#2-Sharepreference源码分析" class="headerlink" title="2.Sharepreference源码分析"></a>2.Sharepreference源码分析</h3><h4 id="2-1获取Sharepreference"><a href="#2-1获取Sharepreference" class="headerlink" title="2.1获取Sharepreference"></a>2.1获取Sharepreference</h4><p>Activity.java</p><pre><code>    public SharedPreferences getPreferences(int mode) {        return getSharedPreferences(getLocalClassName(), mode);    }        @Override    public SharedPreferences getSharedPreferences(String name, int mode) {        return mBase.getSharedPreferences(name, mode);    }</code></pre><p>Context采用的是装饰模式，其中正在干活的是ContextImpl，mBase即为ContextImpl，具体代码如下：<br>ContextImpl.java</p><pre><code class="java">//ContextImpl类中的静态Map声明，全局的一个sSharedPrefsprivate static ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt; sSharedPrefs;    @Override    public SharedPreferences getSharedPreferences(String name, int mode) {        SharedPreferencesImpl sp;         synchronized (ContextImpl.class) {            if (sSharedPrefs == null) { //静态变量，全局唯一                sSharedPrefs = new ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt;();            }            final String packageName = getPackageName();//通过包名找到对应的prefs集合            ArrayMap&lt;String, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefs.get(packageName);            if (packagePrefs == null) {                packagePrefs = new ArrayMap&lt;String, SharedPreferencesImpl&gt;();                sSharedPrefs.put(packageName, packagePrefs);            }            // At least one application in the world actually passes in a null            // name.  This happened to work because when we generated the file name            // we would stringify it to &quot;null.xml&quot;.  Nice.            if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;                    Build.VERSION_CODES.KITKAT) {                if (name == null) {                    name = &quot;null&quot;;                }            }            sp = packagePrefs.get(name);//这里获取sp            if (sp == null) {//如果为空，则构建一个sp，并将它放入packagePrefs里面                File prefsFile = getSharedPrefsFile(name);//正在获取文件的地方                sp = new SharedPreferencesImpl(prefsFile, mode);                packagePrefs.put(name, sp);                return sp;            }        }        //下面是为了跨进程使用Sharepreference的，跨进程使用也就是重新装载一次sharepreference        if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 ||            getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) {            // If somebody else (some other process) changed the prefs            // file behind our back, we reload it.  This has been the            // historical (if undocumented) behavior.            sp.startReloadIfChangedUnexpectedly();        }        return sp;    }</code></pre><p>正在保存的文件获取是getSharedPrefsFile(name)，代码如下：</p><pre><code class="java">    @Override    public File getSharedPrefsFile(String name) { //文件以.xml结尾        return makeFilename(getPreferencesDir(), name + &quot;.xml&quot;);    }    private File makeFilename(File base, String name) {        if (name.indexOf(File.separatorChar) &lt; 0) { //name中不能存在文件路径分隔符            return new File(base, name);        }        throw new IllegalArgumentException(                &quot;File &quot; + name + &quot; contains a path separator&quot;);    }    private File getPreferencesDir() {//sharepreference文件的目录/data/data/{包名}/shared_prefs        synchronized (mSync) {            if (mPreferencesDir == null) {                mPreferencesDir = new File(getDataDirFile(), &quot;shared_prefs&quot;);            }            return mPreferencesDir;        }    }</code></pre><p>在ContextImpl中存在一个静态的sSharedPrefs，通过它来获取对应应用的prefs，在通过prefs找到对应名称的Sharepreference的引用。在系统中共用一个sSharedPrefs，每个应该在获取sp的时候都会将创建后sp加入到sSharedPrefs中以便后续进行访问。</p><h4 id="2-2-SharepreferenceImpl"><a href="#2-2-SharepreferenceImpl" class="headerlink" title="2.2 SharepreferenceImpl"></a>2.2 SharepreferenceImpl</h4><pre><code>从上面我们可以看到我们要获取的是Sharepreference，但是返回的是SharepreferenceImpl，这就赤裸裸的告诉我们SharepreferenceImpl是Sharepreference接口的实现类，具体代码如下：</code></pre><pre><code class="java">final class SharedPreferencesImpl implements SharedPreferences {    private static final String TAG = &quot;SharedPreferencesImpl&quot;;    private static final boolean DEBUG = false;    // Lock ordering rules:    //  - acquire SharedPreferencesImpl.this before EditorImpl.this    //  - acquire mWritingToDiskLock before EditorImpl.this    private final File mFile;    private final File mBackupFile;    private final int mMode;    private Map&lt;String, Object&gt; mMap;     // guarded by &#39;this&#39;    private int mDiskWritesInFlight = 0;  // guarded by &#39;this&#39;    private boolean mLoaded = false;      // guarded by &#39;this&#39;    private long mStatTimestamp;          // guarded by &#39;this&#39;    private long mStatSize;               // guarded by &#39;this&#39;    private final Object mWritingToDiskLock = new Object();    private static final Object mContent = new Object();    private final WeakHashMap&lt;OnSharedPreferenceChangeListener, Object&gt; mListeners =            new WeakHashMap&lt;OnSharedPreferenceChangeListener, Object&gt;();    SharedPreferencesImpl(File file, int mode) {        mFile = file;        mBackupFile = makeBackupFile(file); //创建临时备份文件，这样写入失败的时候就用这个备份的还原        mMode = mode;        mLoaded = false;        mMap = null;        startLoadFromDisk();//异步加载文件内容到内存    }    private void startLoadFromDisk() {        synchronized (this) {            mLoaded = false;        }        new Thread(&quot;SharedPreferencesImpl-load&quot;) {            public void run() {                //由于是多线程加载的时候注意同步处理                synchronized (SharedPreferencesImpl.this) {                    loadFromDiskLocked();                }            }        }.start();    }...  private static File makeBackupFile(File prefsFile) {        return new File(prefsFile.getPath() + &quot;.bak&quot;);    }...}</code></pre><p>在获取sp的时候，如果通过sSharedPrefs获取为空就会先创建一个sp，在new SharepreferenceImpl的时候，在构造函数中最后就会异步加载文件到内存，异步开启一个线程后就调用loadFromDiskLocked()函数进行加载：<br>SharepreferenceImpl.java</p><pre><code class="java">    private void loadFromDiskLocked() {        if (mLoaded) {//加载过了就返回            return;        }        if (mBackupFile.exists()) {//如果存在备份就直接使用备份            mFile.delete();            mBackupFile.renameTo(mFile);        }        // Debugging        if (mFile.exists() &amp;&amp; !mFile.canRead()) {            Log.w(TAG, &quot;Attempt to read preferences file &quot; + mFile + &quot; without permission&quot;);        }        Map map = null;        StructStat stat = null;        try {            stat = Os.stat(mFile.getPath());            if (mFile.canRead()) {                BufferedInputStream str = null;                try {                    str = new BufferedInputStream(                            new FileInputStream(mFile), 16*1024);                    map = XmlUtils.readMapXml(str);//利用XmlUtils进行解析                } catch (XmlPullParserException e) {                    Log.w(TAG, &quot;getSharedPreferences&quot;, e);                } catch (FileNotFoundException e) {                    Log.w(TAG, &quot;getSharedPreferences&quot;, e);                } catch (IOException e) {                    Log.w(TAG, &quot;getSharedPreferences&quot;, e);                } finally {                    IoUtils.closeQuietly(str);                }            }        } catch (ErrnoException e) {        }        mLoaded = true;        if (map != null) {            mMap = map;            mStatTimestamp = stat.st_mtime;            mStatSize = stat.st_size;        } else {            mMap = new HashMap&lt;String, Object&gt;();        }        notifyAll();//没加载完前，所有操作（get等）都会等待加载完成，加载完成后通知其他操作可以进行操作了。    }</code></pre><p>一旦加载完成后，就会notifyAll()，我们先看下get的操作</p><pre><code class="java">    public Map&lt;String, ?&gt; getAll() {        synchronized (this) {            awaitLoadedLocked();            //noinspection unchecked            return new HashMap&lt;String, Object&gt;(mMap);        }    }    @Nullable    public String getString(String key, @Nullable String defValue) {        synchronized (this) {            awaitLoadedLocked();//没有加载就阻塞等待            String v = (String)mMap.get(key);//加载完成了就直接去内存中的值，记住是从内存中取。不会再次读取文件总内容。            return v != null ? v : defValue;        }    }...    private void awaitLoadedLocked() {//这里判断是否已经加载文件到内存了，没有加载就会阻塞等待        if (!mLoaded) {            // Raise an explicit StrictMode onReadFromDisk for this            // thread, since the real read will be in a different            // thread and otherwise ignored by StrictMode.            BlockGuard.getThreadPolicy().onReadFromDisk();        }        while (!mLoaded) {            try {                wait();            } catch (InterruptedException unused) {            }        }    }</code></pre><p>在get数据时，首先判断文件是否加载到内存，然后就直接读取内存中的值，这里可以看出一旦装载了，那么读取的速度就很快。</p><h4 id="2-3-EditorImpl"><a href="#2-3-EditorImpl" class="headerlink" title="2.3 EditorImpl"></a>2.3 EditorImpl</h4><p>上面SharepreferenceImpl是实现了get操作，真正的写入是Editor接口来完成的，而EditorImpl是具体的实现类。其代码如下：</p><pre><code class="java">    public final class EditorImpl implements Editor {        private final Map&lt;String, Object&gt; mModified = Maps.newHashMap();        private boolean mClear = false;        //从这里可以看出每次存的时候都是先存入内存中的mModified变量中        public Editor putString(String key, @Nullable String value) {            synchronized (this) {                mModified.put(key, value);                return this;            }        }        public Editor putStringSet(String key, @Nullable Set&lt;String&gt; values) {            synchronized (this) {                mModified.put(key,                        (values == null) ? null : new HashSet&lt;String&gt;(values));                return this;            }        }        public Editor putInt(String key, int value) {            synchronized (this) {                mModified.put(key, value);                return this;            }        }...        public Editor remove(String key) {            synchronized (this) {                mModified.put(key, this);                return this;            }        }        public Editor clear() {            synchronized (this) {                mClear = true;                return this;            }        }        public void apply() {            final MemoryCommitResult mcr = commitToMemory();            final Runnable awaitCommit = new Runnable() {                    public void run() {                        try {                            mcr.writtenToDiskLatch.await();                        } catch (InterruptedException ignored) {                        }                    }                };            QueuedWork.add(awaitCommit);            Runnable postWriteRunnable = new Runnable() {                    public void run() {                        awaitCommit.run();                        QueuedWork.remove(awaitCommit);                    }                };            SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);            // Okay to notify the listeners before it&#39;s hit disk            // because the listeners should always get the same            // SharedPreferences instance back, which has the            // changes reflected in memory.            notifyListeners(mcr);        }    }</code></pre><p>首先查看下存入的代码：</p><pre><code>        //从这里可以看出每次存的时候都是先存入内存中的mModified变量中        public Editor putString(String key, @Nullable String value) {            synchronized (this) {                mModified.put(key, value);                return this;            }        }</code></pre><p>存入的时候首先获取同步锁，然后将存入的数据放入EditorImpl中的一个mModified变量中，也就是存入的时候并没有放入Sharepreference中，只有在使用了apply或者commit后才真正存入。<br>下面来看看commit操作：</p><pre><code class="java">        public boolean commit() {            MemoryCommitResult mcr = commitToMemory();//步骤1            SharedPreferencesImpl.this.enqueueDiskWrite(                mcr, null /* sync write on this thread okay */);//步骤2            try {                mcr.writtenToDiskLatch.await();//等待写入完成            } catch (InterruptedException e) {                return false;            }            notifyListeners(mcr);//步骤3            return mcr.writeToDiskResult;步骤4        }</code></pre><p>步骤1：</p><pre><code>        // Returns true if any changes were made 真正存入文件中        private MemoryCommitResult commitToMemory() {            MemoryCommitResult mcr = new MemoryCommitResult();            synchronized (SharedPreferencesImpl.this) {                // We optimistically don&#39;t make a deep copy until                // a memory commit comes in when we&#39;re already                // writing to disk.                if (mDiskWritesInFlight &gt; 0) {                    // We can&#39;t modify our mMap as a currently                    // in-flight write owns it.  Clone it before                    // modifying it.                    // noinspection unchecked                    mMap = new HashMap&lt;String, Object&gt;(mMap);                }                mcr.mapToWriteToDisk = mMap;                mDiskWritesInFlight++;                boolean hasListeners = mListeners.size() &gt; 0;                if (hasListeners) {                    mcr.keysModified = new ArrayList&lt;String&gt;();                    mcr.listeners =                            new HashSet&lt;OnSharedPreferenceChangeListener&gt;(mListeners.keySet());                }                synchronized (this) {                    if (mClear) {                        if (!mMap.isEmpty()) {                            mcr.changesMade = true;                            mMap.clear();                        }                        mClear = false;                    }                    for (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) {                        String k = e.getKey();                        Object v = e.getValue();                        // &quot;this&quot; is the magic value for a removal mutation. In addition,                        // setting a value to &quot;null&quot; for a given key is specified to be                        // equivalent to calling remove on that key.                        //删除一些需要删除的数据                        if (v == this || v == null) {                            if (!mMap.containsKey(k)) {                                continue;                            }                            mMap.remove(k);                        } else {                            if (mMap.containsKey(k)) {                                Object existingValue = mMap.get(k);                                if (existingValue != null &amp;&amp; existingValue.equals(v)) {                                    continue;                                }                            }                            //将变化的数据放入SharepreferenceImpl的mMap中                            mMap.put(k, v);                        }                        mcr.changesMade = true;                        if (hasListeners) {                            mcr.keysModified.add(k);                        }                    }                    //变化的数据都加入了mMap后就可以清除mModified内容了。                    mModified.clear();                }            }            //返回封装mMap的MemoryCommitResult数据            return mcr;        }</code></pre><p>步骤2：</p><pre><code>private void enqueueDiskWrite(final MemoryCommitResult mcr,                                  final Runnable postWriteRunnable) {        final Runnable writeToDiskRunnable = new Runnable() {                public void run() {                    synchronized (mWritingToDiskLock) {                        writeToFile(mcr);                    }                    synchronized (SharedPreferencesImpl.this) {                        mDiskWritesInFlight--;                    }                    if (postWriteRunnable != null) {                        postWriteRunnable.run();                    }                }            };      final boolean isFromSyncCommit = (postWriteRunnable == null);//如果postWriteRunnable为null就是同步        // Typical #commit() path with fewer allocations, doing a write on        // the current thread.        if (isFromSyncCommit) {//同步就直接运行写入数据writeToDiskRunnable            boolean wasEmpty = false;            synchronized (SharedPreferencesImpl.this) {                wasEmpty = mDiskWritesInFlight == 1;            }            if (wasEmpty) {                writeToDiskRunnable.run();                return;            }        }        QueuedWork.singleThreadExecutor().execute(writeToDiskRunnable);    }// 写入数据    private void writeToFile(MemoryCommitResult mcr) {        // Rename the current file so it may be used as a backup during the next read        if (mFile.exists()) {            if (!mcr.changesMade) {                // If the file already exists, but no changes were                // made to the underlying map, it&#39;s wasteful to                // re-write the file.  Return as if we wrote it                // out.                mcr.setDiskWriteResult(true);                return;            }            if (!mBackupFile.exists()) {                if (!mFile.renameTo(mBackupFile)) {                    Log.e(TAG, &quot;Couldn&#39;t rename file &quot; + mFile                          + &quot; to backup file &quot; + mBackupFile);                    mcr.setDiskWriteResult(false);                    return;                }            } else {                mFile.delete();            }        }        // Attempt to write the file, delete the backup and return true as atomically as        // possible.  If any exception occurs, delete the new file; next time we will restore        // from the backup.        try {            FileOutputStream str = createFileOutputStream(mFile);            if (str == null) {                mcr.setDiskWriteResult(false);                return;            }            XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);            FileUtils.sync(str);            str.close();            ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);            try {                final StructStat stat = Os.stat(mFile.getPath());                synchronized (this) {                    mStatTimestamp = stat.st_mtime;                    mStatSize = stat.st_size;                }            } catch (ErrnoException e) {                // Do nothing            }            // Writing was successful, delete the backup file if there is one.            mBackupFile.delete();            mcr.setDiskWriteResult(true);            return;        } catch (XmlPullParserException e) {            Log.w(TAG, &quot;writeToFile: Got exception:&quot;, e);        } catch (IOException e) {            Log.w(TAG, &quot;writeToFile: Got exception:&quot;, e);        }        // Clean up an unsuccessfully written file        if (mFile.exists()) {            if (!mFile.delete()) {                Log.e(TAG, &quot;Couldn&#39;t clean up partially-written file &quot; + mFile);            }        }        mcr.setDiskWriteResult(false);    }</code></pre><p>步骤3通知写入数据发生变化</p><pre><code>        private void notifyListeners(final MemoryCommitResult mcr) {            if (mcr.listeners == null || mcr.keysModified == null ||                mcr.keysModified.size() == 0) {                return;            }            if (Looper.myLooper() == Looper.getMainLooper()) {                for (int i = mcr.keysModified.size() - 1; i &gt;= 0; i--) {                    final String key = mcr.keysModified.get(i);                    for (OnSharedPreferenceChangeListener listener : mcr.listeners) {                        if (listener != null) {                            listener.onSharedPreferenceChanged(SharedPreferencesImpl.this, key);                        }                    }                }            } else {                // Run this function on the main thread.                ActivityThread.sMainThreadHandler.post(new Runnable() {                        public void run() {                            notifyListeners(mcr);                        }                    });            }        }</code></pre><p>步骤4返回写入的结果。</p><h5 id="2-3-2-Editor-apply"><a href="#2-3-2-Editor-apply" class="headerlink" title="2.3.2 Editor.apply()"></a>2.3.2 Editor.apply()</h5><p>代码如下：</p><pre><code>public void apply() {    //写数据到内存，返回数据结构    final MemoryCommitResult mcr = commitToMemory();    final Runnable awaitCommit = new Runnable() {        public void run() {            try {                //等待写文件结束                mcr.writtenToDiskLatch.await();            } catch (InterruptedException ignored) {            }        }    };    QueuedWork.add(awaitCommit);    //一个收尾的Runnable    Runnable postWriteRunnable = new Runnable() {        public void run() {            awaitCommit.run();            QueuedWork.remove(awaitCommit);        }    };    //这里postWriteRunnable不为null，所以会在一个新的线程池调运postWriteRunnable的run方法    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);    // Okay to notify the listeners before it&#39;s hit disk    // because the listeners should always get the same    // SharedPreferences instance back, which has the    // changes reflected in memory.    //通知变化    notifyListeners(mcr);}</code></pre><p>apply会将写入放入到一个线程池中操作，这不会阻塞调用的线程。其他的都和commit类似。<br>QueuedWork.java</p><pre><code>public class QueuedWork {    private static final ConcurrentLinkedQueue&lt;Runnable&gt; sPendingWorkFinishers =       new ConcurrentLinkedQueue&lt;Runnable&gt;();    public static void add(Runnable finisher) {        sPendingWorkFinishers.add(finisher);    }    public static void remove(Runnable finisher) {        sPendingWorkFinishers.remove(finisher);    }    public static void waitToFinish() {        Runnable toFinish;        while ((toFinish = sPendingWorkFinishers.poll()) != null) {            toFinish.run();        }    }    public static boolean hasPendingWork() {        return !sPendingWorkFinishers.isEmpty();    }}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>apply 与commit的对比</p><p>apply没有返回值, commit有返回值能知道修改是否提交成功<br>apply是将修改提交到内存，再异步提交到磁盘文件; commit是同步的提交到磁盘文件;<br>多并发的提交commit时，需等待正在处理的commit数据更新到磁盘文件后才会继续往下执行，从而降低效率; 而apply只是原子更新到内存，后调用apply函数会直接覆盖前面内存数据，从一定程度上提高很多效率。<br>获取SP与Editor:</p><p>getSharedPreferences()是从ContextImpl.sSharedPrefsCache唯一的SPI对象;<br>edit()每次都是创建新的EditorImpl对象.<br>优化建议:</p><p>强烈建议不要在sp里面存储特别大的key/value, 有助于减少卡顿/anr<br>请不要高频地使用apply, 尽可能地批量提交;commit直接在主线程操作, 更要注意了<br>不要使用MODE_MULTI_PROCESS;<br>高频写操作的key与高频读操作的key可以适当地拆分文件, 由于减少同步锁竞争;<br>不要一上来就执行getSharedPreferences().edit(), 应该分成两大步骤来做, 中间可以执行其他代码.<br>不要连续多次edit(), 应该获取一次获取edit(),然后多次执行putxxx(), 减少内存波动; 经常看到大家喜欢封装方法, 结果就导致这种情况的出现.<br>每次commit时会把全部的数据更新的文件, 所以整个文件是不应该过大的, 影响整体性能;</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://gityuan.com/2017/06/18/SharedPreferences/" target="_blank" rel="noopener">Gityuan博客</a><br><a href="http://blog.csdn.net/yanbober/article/details/47866369" target="_blank" rel="noopener">工匠若水</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h3&gt;&lt;p&gt;写这篇博客目的在于巩固自己对SharedPreferences的理解。SharePreferences是Android系统提
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="SharedPreferences Editor" scheme="http://yoursite.com/tags/SharedPreferences-Editor/"/>
    
  </entry>
  
  <entry>
    <title>adb常用命令</title>
    <link href="http://yoursite.com/2018/01/17/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/01/17/adb常用命令/</id>
    <published>2018-01-17T02:15:31.000Z</published>
    <updated>2018-07-30T14:34:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="adb简介"><a href="#adb简介" class="headerlink" title="adb简介"></a>adb简介</h3><p>adb全称Android Debug Bridge，意为安卓调试桥接，即常用于Android手机调试的工具。adb提供了一系列命令可以操作手机，比如安装卸载软件，运行shell命令等等。adb工作方式是采用监听Socket TCP5554等端口的方式让IDE和Qemu通讯。</p><h3 id="常用的adb命令"><a href="#常用的adb命令" class="headerlink" title="常用的adb命令"></a>常用的adb命令</h3><ol><li>取得当前连接电脑的设备的状态<pre><code>adb devices</code></pre></li><li>安装卸载软件<pre><code>adb install  &lt;-r&gt; 文件.apk  //-r表示替换掉原来的apkadb uninstall &lt;-k&gt; {package} //packageName表示应用包名 -k表示保留配置和缓存</code></pre></li><li>获取设备的序列号<pre><code>adb get-serialno //获取设备序列号</code></pre></li><li>访问手机SQLit数据库（手机内部需有sqilte3命令支持）<pre><code>adb shellsqlite3 {数据库文件名}</code></pre></li><li>从电脑上发送文件到手机端<pre><code>adb push {文件路径} {手机端路径}  //文件表示要发送文件的全路径（当前路径下只需写上文件名 {手机端路径}表示拷贝到手机上的路径，/sdcard/表示sd卡根路径</code></pre></li><li>从手机端拉取文件到电脑端<pre><code>adb pull {手机端路径} {保存到电脑端路径}</code></pre></li><li>查看bug报告<pre><code>adb bugreport  //Android7.0及以后支持该功能</code></pre></li><li>获取手机中的第三方包名<pre><code>adb shell pm list packages -3</code></pre></li><li>查看当前正在交互的程序<pre><code>adb shell dumpsys activity | grep &quot;Running activities&quot; -A 7</code></pre></li><li>获取包名所在路径<pre><code>adb shell pm path {package}</code></pre></li><li>Monkey命令<br>全模块：<pre><code>adb shell &quot;monkey --ignore-crashes --ignore-timeouts --throttle 500 --ignore-security-exceptions --monitor-native-crashes --ignore-native-crashes 10000 &gt; sdcard/monkey.txt&quot;</code></pre>单模块<pre><code>adb shell monkey -p com.android.contacts --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes --ignore-native-crashes --throttle 500 -v 10000 &gt; sdcard/monkey.txt&quot;</code></pre></li><li>强行停止monkey<pre><code>adb shellps | grep monkeykill monkey对应的pid</code></pre></li><li>列出所有可以dump的选项<pre><code>adb shell dumpsys -l</code></pre></li><li>查看内存信息<pre><code>adb shell dumpsys meminfo</code></pre></li><li>列出dumpsys能提供的所有服务列表<pre><code>adb shell dumpsys service list //得到该列表后，就可以在dumpsys后面加上service的名称来查看指定service的信息了</code></pre></li><li>查看ActvityManagerService 所有信息<pre><code>adb shell dumpsys activity</code></pre></li><li>查看Activity组件信息<pre><code>adb shell dumpsys activity activities</code></pre></li><li>查看Service组件信息<pre><code>adb shell dumpsys activity services</code></pre></li><li>产看ContentProvider组件信息<pre><code>adb shell dumpsys activity providers</code></pre></li><li>查看BraodcastReceiver信息<pre><code>adb shell dumpsys activity broadcasts</code></pre></li><li>查看Intent信息<pre><code>adb shell dumpsys activity intents</code></pre></li><li>查看进程信息<pre><code>adb shell dumpsys activity processes</code></pre></li><li>关闭或开启adb服务<pre><code>adb kill-serveradb start-server</code></pre></li><li>显示或导出log信息<pre><code>adb logcat &lt;-s&gt; //在命令行显示log信息 -s表示指定标签tagadb logcat &gt; log.txt //将log信息保存到当前目录的log.txt文件中</code></pre></li><li>启动Activities<pre><code>adb shell am start -n {包名}/{包名＋类名}（-n 类名,-a action,-d date,-m MIME-TYPE,-c category,-e 扩展数据,等）</code></pre></li><li>设置系统属性信息<pre><code>adb shell setprop {key} {value}</code></pre></li><li>常用的adb shell命令<pre><code>ps //列出所有进程ls //列出当前目录下文件df //检查文件系统的磁盘空间占用情况cat //查看某个文件kill {pid}//杀死某个进程cd //进入其他目录rm //删除rmdir //删除非空文件夹（有文件的文件夹可能不成功）</code></pre></li><li>显示WiFi信息<pre><code>adb shell dumpsys wifi</code></pre></li><li>模拟用户点击<pre><code>adb shell input tap {x} {x} //例子：adb shell input tap 50 250</code></pre></li><li>模拟用户滑动<pre><code>adb shell input swipe {start.x} {start.y} {end.x} {end.y} {time} //例子：adb shell input swipe 50 250 250 250 500 //划屏操作，前四个数为坐标点，后面是滑动的时间（单位毫秒）</code></pre></li><li>模拟输入字符串<pre><code>adb shell input text &#39;abc&#39;</code></pre></li><li>模拟点击手机自带的功能键：Home，Menu，Back<pre><code>adb shell input keyevent keyCodekeyCode对应表：KEYCODE_UNKNOWN=0;KEYCODE_SOFT_LEFT=1;   KEYCODE_SOFT_RIGHT=2;   KEYCODE_HOME=3;   KEYCODE_BACK=4;   KEYCODE_CALL=5;   KEYCODE_ENDCALL=6;   KEYCODE_0=7;   KEYCODE_1=8;   KEYCODE_2=9;   KEYCODE_4=11;   KEYCODE_5=12;   KEYCODE_6=13;   KEYCODE_7=14;   KEYCODE_8=15;   KEYCODE_9=16;   KEYCODE_STAR=17;   KEYCODE_POUND=18;   KEYCODE_DPAD_UP=19;   KEYCODE_DPAD_DOWN=20;   KEYCODE_DPAD_LEFT=21;   KEYCODE_DPAD_RIGHT=22;   KEYCODE_DPAD_CENTER=23;   KEYCODE_VOLUME_UP=24;   KEYCODE_VOLUME_DOWN=25;   KEYCODE_POWER=26;   KEYCODE_CAMERA=27;   KEYCODE_CLEAR=28;   KEYCODE_A=29;   KEYCODE_B=30;   KEYCODE_C=31;   KEYCODE_D=32;   KEYCODE_E=33;   KEYCODE_F=34;   KEYCODE_G=35;   KEYCODE_H=36;   KEYCODE_I=37;   KEYCODE_J=38;   KEYCODE_K=39;   KEYCODE_L=40;   KEYCODE_M=41;   KEYCODE_N=42;   KEYCODE_O=43;   KEYCODE_P=44;   KEYCODE_Q=45;   KEYCODE_R=46;   KEYCODE_S=47;   KEYCODE_T=48;   KEYCODE_U=49;   KEYCODE_V=50;   KEYCODE_W=51;   KEYCODE_X=52;   KEYCODE_Y=53;   KEYCODE_Z=54;   KEYCODE_COMMA=55;   KEYCODE_PERIOD=56;   KEYCODE_ALT_LEFT=57;   KEYCODE_ALT_RIGHT=58;   KEYCODE_SHIFT_LEFT=59;   KEYCODE_SHIFT_RIGHT=60;   KEYCODE_TAB=61;   KEYCODE_SPACE=62;   KEYCODE_SYM=63;   KEYCODE_EXPLORER=64;   KEYCODE_ENVELOPE=65;   KEYCODE_ENTER=66;   KEYCODE_DEL=67;   KEYCODE_GRAVE=68;   KEYCODE_MINUS=69;   KEYCODE_EQUALS=70;   KEYCODE_LEFT_BRACKET=71;   KEYCODE_RIGHT_BRACKET=72;   KEYCODE_BACKSLASH=73;   KEYCODE_SEMICOLON=74;   KEYCODE_APOSTROPHE=75;   KEYCODE_SLASH=76;   KEYCODE_AT=77;   KEYCODE_NUM=78;   KEYCODE_HEADSETHOOK=79;   KEYCODE_FOCUS=80;//*Camera*focus   KEYCODE_PLUS=81;   KEYCODE_MENU=82;   KEYCODE_NOTIFICATION=83;   KEYCODE_SEARCH=84;   KEYCODE_MEDIA_PLAY_PAUSE=85;   KEYCODE_MEDIA_STOP=86;   KEYCODE_MEDIA_NEXT=87;   KEYCODE_MEDIA_PREVIOUS=88;   KEYCODE_MEDIA_REWIND=89;   KEYCODE_MEDIA_FAST_FORWARD=90;   KEYCODE_MUTE=91;</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;adb简介&quot;&gt;&lt;a href=&quot;#adb简介&quot; class=&quot;headerlink&quot; title=&quot;adb简介&quot;&gt;&lt;/a&gt;adb简介&lt;/h3&gt;&lt;p&gt;adb全称Android Debug Bridge，意为安卓调试桥接，即常用于Android手机调试的工具。adb提
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="adb命令" scheme="http://yoursite.com/tags/adb%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>onAttachedToWindow和onDetachedFromWindow调用时机源码解析</title>
    <link href="http://yoursite.com/2018/01/09/onAttachedToWindow%E5%92%8ConDetachedFromWindow%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/01/09/onAttachedToWindow和onDetachedFromWindow调用时机源码解析/</id>
    <published>2018-01-09T14:56:44.000Z</published>
    <updated>2018-07-30T14:34:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-示例"><a href="#1-示例" class="headerlink" title="1.示例"></a>1.示例</h3><p>先上测试代码：<br>MyView.java</p><pre><code class="java">public class MyView extends TextView {      public MyView(Context context) {          super(context);      }      public MyView(Context context, AttributeSet attrs) {          super(context, attrs);          Log.e(&quot;test&quot;,&quot;view constructor&quot;);      }      @Override      protected void onAttachedToWindow() {          super.onAttachedToWindow();          Log.e(&quot;test&quot;, &quot;onAttachedToWindow&quot;);      }      @Override      protected void onDetachedFromWindow() {          super.onDetachedFromWindow();          Log.e(&quot;test&quot;, &quot;onDetachedFromWindow&quot;);      }  }</code></pre><p>MainActivity.java</p><pre><code class="java">public class MainActivity extends AppCompatActivity {      @Override      protected void onCreate(Bundle savedInstanceState) {          super.onCreate(savedInstanceState);          Log.e(&quot;test&quot;, &quot;before setContextView&quot;);          setContentView(R.layout.activity_main);          Log.e(&quot;test&quot;, &quot;after setContextView&quot;);      }      @Override      protected void onResume() {          super.onResume();          Log.e(&quot;test&quot;, &quot;onResume&quot;);      }      @Override      protected void onDestroy() {          super.onDestroy();          Log.e(&quot;test&quot;, &quot;onDestroy&quot;);      }  }</code></pre><p> 运行后输出的Log如下：<br> <img src="http://img.blog.csdn.net/20170801103513570?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="运行后Log"><br>点击返回键退出后，输出的Log如下：<br><img src="http://img.blog.csdn.net/20170801103610947?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="点击返回后Log"></p><p>根据Log的onAttachedToWindow和onDetachedFromWindow的输出情况一目了然。</p><h3 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h3><p>下面通过源码分析下，他两的调用时机到底在哪。</p><p>首先看下onAttachedToWindow的调用时机，在Android源码中onResume调用前会先调用了ActivityThread中的handleResumeActivity，下面是相应的代码：</p><p>ActivityThread.java</p><pre><code class="java">final void handleResumeActivity(IBinder token,              boolean clearHide, boolean isForward, boolean reallyResume) {          // If we are getting ready to gc after going to the background, well          // we are back active so skip it.          unscheduleGcIdler();          mSomeActivitiesChanged = true;          // TODO Push resumeArgs into the activity for consideration          ActivityClientRecord r = performResumeActivity(token, clearHide);          if (r != null) {              final Activity a = r.activity;              if (localLOGV) Slog.v(                  TAG, &quot;Resume &quot; + r + &quot; started activity: &quot; +                  a.mStartedActivity + &quot;, hideForNow: &quot; + r.hideForNow                  + &quot;, finished: &quot; + a.mFinished);              final int forwardBit = isForward ?                      WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;              // If the window hasn&#39;t yet been added to the window manager,              // and this guy didn&#39;t finish itself or start another activity,              // then go ahead and add the window.              boolean willBeVisible = !a.mStartedActivity;              if (!willBeVisible) {                  try {                      willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible(                              a.getActivityToken());                  } catch (RemoteException e) {                  }              }              if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) {                  r.window = r.activity.getWindow();                  View decor = r.window.getDecorView();                  decor.setVisibility(View.INVISIBLE);                  ViewManager wm = a.getWindowManager();                  WindowManager.LayoutParams l = r.window.getAttributes();                  a.mDecor = decor;                  l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;                  l.softInputMode |= forwardBit;                  if (a.mVisibleFromClient) {                      a.mWindowAdded = true;                      wm.addView(decor, l);//这里调用了ViewManager中的addView方法。                  }              // If the window has already been added, but during resume              // we started another activity, then don&#39;t yet make the              // window visible.              } else if (!willBeVisible) {                  if (localLOGV) Slog.v(                      TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;);                  r.hideForNow = true;              }              // Get rid of anything left hanging around.              cleanUpPendingRemoveWindows(r);              // The window is now visible if it has been added, we are not              // simply finishing, and we are not starting another activity.              if (!r.activity.mFinished &amp;&amp; willBeVisible                      &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) {                  if (r.newConfig != null) {                      r.tmpConfig.setTo(r.newConfig);                      if (r.overrideConfig != null) {                          r.tmpConfig.updateFrom(r.overrideConfig);                      }                      if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot;                              + r.activityInfo.name + &quot; with newConfig &quot; + r.tmpConfig);                      performConfigurationChanged(r.activity, r.tmpConfig);                      freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig));                      r.newConfig = null;                  }                  if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot;                          + isForward);                  WindowManager.LayoutParams l = r.window.getAttributes();                  if ((l.softInputMode                          &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)                          != forwardBit) {                      l.softInputMode = (l.softInputMode                              &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))                              | forwardBit;                      if (r.activity.mVisibleFromClient) {                          ViewManager wm = a.getWindowManager();                          View decor = r.window.getDecorView();                          wm.updateViewLayout(decor, l);                      }                  }                  r.activity.mVisibleFromServer = true;                  mNumVisibleActivities++;                  if (r.activity.mVisibleFromClient) {                      r.activity.makeVisible();                  }              }              ....      }</code></pre><p>看代码中的wm.addView(devor,l);通过该方法将View添加到Window当中（在当前Window也就是Activity，不过Window也可以是Dialog或Toast），而wm是ViewManager类型的，查看对应代码是：</p><pre><code class="java">/** Interface to let you add and remove child views to an Activity. To get an instance   * of this class, call {@link android.content.Context#getSystemService(java.lang.String) Context.getSystemService()}.   */  public interface ViewManager  {      /**      * Assign the passed LayoutParams to the passed View and add the view to the window.      * &lt;p&gt;Throws {@link android.view.WindowManager.BadTokenException} for certain programming      * errors, such as adding a second view to a window without removing the first view.      * &lt;p&gt;Throws {@link android.view.WindowManager.InvalidDisplayException} if the window is on a      * secondary {@link Display} and the specified display can&#39;t be found      * (see {@link android.app.Presentation}).      * @param view The view to be added to this window.      * @param params The LayoutParams to assign to view.      */      public void addView(View view, ViewGroup.LayoutParams params);      public void updateViewLayout(View view, ViewGroup.LayoutParams params);      public void removeView(View view);  }</code></pre><p> 该类是一个接口，在他下面还有一个WindowManager继承于ViewManager，而真正的实现代码在WindowManagerImpl类中，代码如下：<br>WindowManagerImpl.java</p><pre><code class="java">/* * @see WindowManager * @see WindowManagerGlobal * @hide */  ublic final class WindowManagerImpl implements WindowManager {     private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();     private final Display mDisplay;     private final Window mParentWindow;     private IBinder mDefaultToken;     public WindowManagerImpl(Display display) {         this(display, null);     }     private WindowManagerImpl(Display display, Window parentWindow) {         mDisplay = display;         mParentWindow = parentWindow;     }     public WindowManagerImpl createLocalWindowManager(Window parentWindow) {         return new WindowManagerImpl(mDisplay, parentWindow);     }     public WindowManagerImpl createPresentationWindowManager(Display display) {         return new WindowManagerImpl(display, mParentWindow);     }     /**     * Sets the window token to assign when none is specified by the client or     * available from the parent window.     *     * @param token The default token to assign.     */     public void setDefaultToken(IBinder token) {         mDefaultToken = token;     }     @Override     public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {         applyDefaultToken(params);         mGlobal.addView(view, params, mDisplay, mParentWindow);     }     @Override     public void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {         applyDefaultToken(params);         mGlobal.updateViewLayout(view, params);     }     private void applyDefaultToken(@NonNull ViewGroup.LayoutParams params) {         // Only use the default token if we don&#39;t have a parent window.         if (mDefaultToken != null &amp;&amp; mParentWindow == null) {             if (!(params instanceof WindowManager.LayoutParams)) {                 throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;);             }             // Only use the default token if we don&#39;t already have a token.             final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;             if (wparams.token == null) {                 wparams.token = mDefaultToken;             }         }     }     @Override     public void removeView(View view) {         mGlobal.removeView(view, false);     }     @Override     public void removeViewImmediate(View view) {         mGlobal.removeView(view, true);     }     @Override     public Display getDefaultDisplay() {         return mDisplay;     }</code></pre><p>从中可以看到addView又调用了 WindowManagerGlobal.java类中的addView，下面看看WindowManagerGlobal.java类的源码：<br>WindowManagerGlobal.java</p><pre><code class="java">public void addView(View view, ViewGroup.LayoutParams params,          Display display, Window parentWindow) {      if (view == null) {          throw new IllegalArgumentException(&quot;view must not be null&quot;);      }      if (display == null) {          throw new IllegalArgumentException(&quot;display must not be null&quot;);      }      if (!(params instanceof WindowManager.LayoutParams)) {          throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;);      }      final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;      if (parentWindow != null) {          parentWindow.adjustLayoutParamsForSubWindow(wparams);      } else {          // If there&#39;s no parent, then hardware acceleration for this view is          // set from the application&#39;s hardware acceleration setting.          final Context context = view.getContext();          if (context != null                  &amp;&amp; (context.getApplicationInfo().flags                          &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) {              wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;          }      }      ViewRootImpl root;      View panelParentView = null;      synchronized (mLock) {          // Start watching for system property changes.          if (mSystemPropertyUpdater == null) {              mSystemPropertyUpdater = new Runnable() {                  @Override public void run() {                      synchronized (mLock) {                          for (int i = mRoots.size() - 1; i &gt;= 0; --i) {                              mRoots.get(i).loadSystemProperties();                          }                      }                  }              };              SystemProperties.addChangeCallback(mSystemPropertyUpdater);          }          int index = findViewLocked(view, false);          if (index &gt;= 0) {              if (mDyingViews.contains(view)) {                  // Don&#39;t wait for MSG_DIE to make it&#39;s way through root&#39;s queue.                  mRoots.get(index).doDie();              } else {                  throw new IllegalStateException(&quot;View &quot; + view                          + &quot; has already been added to the window manager.&quot;);              }              // The previous removeView() had not completed executing. Now it has.          }          // If this is a panel window, then find the window it is being          // attached to for future reference.          if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;                  wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) {              final int count = mViews.size();              for (int i = 0; i &lt; count; i++) {                  if (mRoots.get(i).mWindow.asBinder() == wparams.token) {                      panelParentView = mViews.get(i);                  }              }          }          root = new ViewRootImpl(view.getContext(), display);          view.setLayoutParams(wparams);          mViews.add(view);          mRoots.add(root);          mParams.add(wparams);      }      // do this last because it fires off messages to start doing things      try {          root.setView(view, wparams, panelParentView);//这里调用ViewRootImpl类中的setView方法，在该方法中触发了&lt;span style=&quot;color: rgb(101, 123, 131); font-family: Menlo, Monaco, Consolas, &#39;Courier New&#39;, monospace; line-height: 20.4px; white-space: pre-wrap; background-color: rgb(246, 246, 246);&quot;&gt;ViewRootImpl.performTraversals()&lt;/span&gt;      } catch (RuntimeException e) {          // BadTokenException or InvalidDisplayException, clean up.          synchronized (mLock) {              final int index = findViewLocked(view, false);              if (index &gt;= 0) {                  removeViewLocked(index, true);              }          }          throw e;      }  }</code></pre><p>在该方法中的root.setView(view,wparams,panelParentView)方法，调用的是ViewRootImpl类中的setView方法，正是该setView方法触发了ViewRootImpl.performTraversals()方法，也就是View绘制的起点，之后会进行measure,layout,draw三个步骤从而完成一个View的显示工作。</p><p>ViewRootImpl.java</p><pre><code class="java">/**  * We have one child  */  public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {      synchronized (this) {          if (mView == null) {              mView = view;              mAttachInfo.mDisplayState = mDisplay.getState();              mDisplayManager.registerDisplayListener(mDisplayListener, mHandler);              ...              mSoftInputMode = attrs.softInputMode;              mWindowAttributesChanged = true;              mWindowAttributesChangesFlag = WindowManager.LayoutParams.EVERYTHING_CHANGED;              mAttachInfo.mRootView = view;              mAttachInfo.mScalingRequired = mTranslator != null;              mAttachInfo.mApplicationScale =                      mTranslator == null ? 1.0f : mTranslator.applicationScale;              if (panelParentView != null) {                  mAttachInfo.mPanelParentWindowToken                          = panelParentView.getApplicationWindowToken();              }              mAdded = true;              int res; /* = WindowManagerImpl.ADD_OKAY; */              // Schedule the first layout -before- adding to the window              // manager, to make sure we do the relayout before receiving              // any other events from the system.              requestLayout();//这里开始请求view的绘制              if ((mWindowAttributes.inputFeatures                      &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {                  mInputChannel = new InputChannel();              }              try {                  mOrigWindowType = mWindowAttributes.type;                  mAttachInfo.mRecomputeGlobalAttributes = true;                  collectViewAttributes();                  res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,                          getHostVisibility(), mDisplay.getDisplayId(),                          mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,                          mAttachInfo.mOutsets, mInputChannel);              } catch (RemoteException e) {                  mAdded = false;                  mView = null;                  mAttachInfo.mRootView = null;                  mInputChannel = null;                  mFallbackEventHandler.setView(null);                  unscheduleTraversals();                  setAccessibilityFocus(null, null);                  throw new RuntimeException(&quot;Adding window failed&quot;, e);              } finally {                  if (restore) {                      attrs.restore();                  }              }              ....          }      }  }</code></pre><p>在setView的requestLayout方法中开始View的绘制。<br>ViewRootImpl.java</p><pre><code class="java">void scheduleTraversals() {      if (!mTraversalScheduled) {          mTraversalScheduled = true;          mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();          mChoreographer.postCallback(                  Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);          if (!mUnbufferedInputDispatch) {              scheduleConsumeBatchedInput();          }          notifyRendererOfFramePending();          pokeDrawLockIfNeeded();      }  }  void scheduleTraversals() {      if (!mTraversalScheduled) {          mTraversalScheduled = true;          mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();          mChoreographer.postCallback(                  Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);          if (!mUnbufferedInputDispatch) {              scheduleConsumeBatchedInput();          }          notifyRendererOfFramePending();          pokeDrawLockIfNeeded();      }  }  final class TraversalRunnable implements Runnable {      @Override      public void run() {          doTraversal();      }  }  final TraversalRunnable mTraversalRunnable = new TraversalRunnable();  void doTraversal() {      if (mTraversalScheduled) {          mTraversalScheduled = false;          mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);          if (mProfile) {              Debug.startMethodTracing(&quot;ViewAncestor&quot;);          }          performTraversals();          if (mProfile) {              Debug.stopMethodTracing();              mProfile = false;          }      }  }</code></pre><p> 在scheduleTraversals()方法中向mChoreographer中postCallback，而具体的Runable内容在TraversalRunnable类中，该类在run函数中直接执行doTraversal()方法，可以看到在该方法中最终调用了performTraversals()开启View的绘制工作。<br>查看ViewRootImpl.java中的performTraversals()的源码如下：</p><p>ViewRootImpl.java中的performTraversals()方法</p><pre><code class="java">private void performTraversals() {          // cache mView since it is used so much below...          final View host = mView;          ...          if (host == null || !mAdded)              return;          mIsInTraversal = true;          mWillDrawSoon = true;          boolean windowSizeMayChange = false;          boolean newSurface = false;          boolean surfaceChanged = false;          WindowManager.LayoutParams lp = mWindowAttributes;          int desiredWindowWidth;          int desiredWindowHeight;          final int viewVisibility = getHostVisibility();          boolean viewVisibilityChanged = mViewVisibility != viewVisibility                  || mNewSurfaceNeeded;          WindowManager.LayoutParams params = null;          if (mWindowAttributesChanged) {              mWindowAttributesChanged = false;              surfaceChanged = true;              params = lp;          }          CompatibilityInfo compatibilityInfo = mDisplayAdjustments.getCompatibilityInfo();          if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {              params = lp;              mFullRedrawNeeded = true;              mLayoutRequested = true;              if (mLastInCompatMode) {                  params.privateFlags &amp;= ~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;                  mLastInCompatMode = false;              } else {                  params.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;                  mLastInCompatMode = true;              }          }          mWindowAttributesChangesFlag = 0;          Rect frame = mWinFrame;          if (mFirst) {              mFullRedrawNeeded = true;              mLayoutRequested = true;              if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL                      || lp.type == WindowManager.LayoutParams.TYPE_INPUT_METHOD) {                  // NOTE -- system code, won&#39;t try to do compat mode.                  Point size = new Point();                  mDisplay.getRealSize(size);                  desiredWindowWidth = size.x;                  desiredWindowHeight = size.y;              } else {                  DisplayMetrics packageMetrics =                      mView.getContext().getResources().getDisplayMetrics();                  desiredWindowWidth = packageMetrics.widthPixels;                  desiredWindowHeight = packageMetrics.heightPixels;              }              // We used to use the following condition to choose 32 bits drawing caches:              // PixelFormat.hasAlpha(lp.format) || lp.format == PixelFormat.RGBX_8888              // However, windows are now always 32 bits by default, so choose 32 bits              mAttachInfo.mUse32BitDrawingCache = true;              mAttachInfo.mHasWindowFocus = false;              mAttachInfo.mWindowVisibility = viewVisibility;              mAttachInfo.mRecomputeGlobalAttributes = false;              viewVisibilityChanged = false;              mLastConfiguration.setTo(host.getResources().getConfiguration());              mLastSystemUiVisibility = mAttachInfo.mSystemUiVisibility;              // Set the layout direction if it has not been set before (inherit is the default)              if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {                  host.setLayoutDirection(mLastConfiguration.getLayoutDirection());              }              host.dispatchAttachedToWindow(mAttachInfo, 0);//这里调用了View的dispatchAttachedToWindow，也就是这里回调了onAttachedToWindow方法。              mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);              dispatchApplyInsets(host);              //Log.i(TAG, &quot;Screen on initialized: &quot; + attachInfo.mKeepScreenOn);          } else {              desiredWindowWidth = frame.width();              desiredWindowHeight = frame.height();              if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {                  if (DEBUG_ORIENTATION) Log.v(TAG,                          &quot;View &quot; + host + &quot; resized to: &quot; + frame);                  mFullRedrawNeeded = true;                  mLayoutRequested = true;                  windowSizeMayChange = true;              }          }          ...      }</code></pre><p>在该方法中调用了host.dispatchAttachedToWindow(mAttachInfo, 0);方法。host是上面传下来的DecodView，该类继承与FrameLayout类，也就是ViewGroup的子类，所以先调用的是ViewGroup中的dispatchAttachedToWindow，其代码如下：</p><p>ViewGroup.java</p><pre><code class="java">@Override  void dispatchAttachedToWindow(AttachInfo info, int visibility) {      mGroupFlags |= FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW;      super.dispatchAttachedToWindow(info, visibility);//这里先调用父类，也就是View的dispathcAttachedToWindow。      mGroupFlags &amp;= ~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW;      final int count = mChildrenCount;      final View[] children = mChildren;      for (int i = 0; i &lt; count; i++) {          final View child = children[i];          child.dispatchAttachedToWindow(info,                  combineVisibility(visibility, child.getVisibility()));//这里调用子View的&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif;&quot;&gt;dispatchAttachedToWindow&lt;/span&gt;      }      final int transientCount = mTransientIndices == null ? 0 : mTransientIndices.size();      for (int i = 0; i &lt; transientCount; ++i) {          View view = mTransientViews.get(i);          view.dispatchAttachedToWindow(info,                  combineVisibility(visibility, view.getVisibility()));      }  }</code></pre><p>下面查看对应的View类中的dispatchAttacToWindow。代码如下：</p><p>View.java</p><pre><code class="java">void dispatchAttachedToWindow(AttachInfo info, int visibility) {          //System.out.println(&quot;Attached! &quot; + this);          mAttachInfo = info;          if (mOverlay != null) {              mOverlay.getOverlayView().dispatchAttachedToWindow(info, visibility);          }          mWindowAttachCount++;          // We will need to evaluate the drawable state at least once.          mPrivateFlags |= PFLAG_DRAWABLE_STATE_DIRTY;          if (mFloatingTreeObserver != null) {              info.mTreeObserver.merge(mFloatingTreeObserver);              mFloatingTreeObserver = null;          }          if ((mPrivateFlags&amp;PFLAG_SCROLL_CONTAINER) != 0) {              mAttachInfo.mScrollContainers.add(this);              mPrivateFlags |= PFLAG_SCROLL_CONTAINER_ADDED;          }          performCollectViewAttributes(mAttachInfo, visibility);          onAttachedToWindow();//快看，快看，在这里！终于找到这个方法调用的位置了          ListenerInfo li = mListenerInfo;          final CopyOnWriteArrayList&lt;OnAttachStateChangeListener&gt; listeners =                  li != null ? li.mOnAttachStateChangeListeners : null;          if (listeners != null &amp;&amp; listeners.size() &gt; 0) {              // NOTE: because of the use of CopyOnWriteArrayList, we *must* use an iterator to              // perform the dispatching. The iterator is a safe guard against listeners that              // could mutate the list by calling the various add/remove methods. This prevents              // the array from being modified while we iterate it.              for (OnAttachStateChangeListener listener : listeners) {                  listener.onViewAttachedToWindow(this);//              }          }          int vis = info.mWindowVisibility;          if (vis != GONE) {              onWindowVisibilityChanged(vis);          }          // Send onVisibilityChanged directly instead of dispatchVisibilityChanged.          // As all views in the subtree will already receive dispatchAttachedToWindow          // traversing the subtree again here is not desired.          onVisibilityChanged(this, visibility);          if ((mPrivateFlags&amp;PFLAG_DRAWABLE_STATE_DIRTY) != 0) {              // If nobody has evaluated the drawable state yet, then do it now.              refreshDrawableState();          }          needGlobalAttributesUpdate(false);      }</code></pre><p> 从上面代码可以看出一个布局的onAttachedToWindow会先调用自己的，然后再调用自己孩子的。而且从View.java的代码中也可以看出onAttachedToWindow和View自身的visibility无关，即使visibility==GONE，该方法也会调用。<br>好，下面来分析下onDetachedFromWindow方法的调用时机。在onDestory调用前会调用ActivityThread.java中的handleDestroyActivity方法，贴出代码：</p><p>ActivityThread.java</p><pre><code class="java">private void handleDestroyActivity(IBinder token, boolean finishing,          int configChanges, boolean getNonConfigInstance) {      ActivityClientRecord r = performDestroyActivity(token, finishing,              configChanges, getNonConfigInstance);      if (r != null) {          cleanUpPendingRemoveWindows(r);          WindowManager wm = r.activity.getWindowManager();          View v = r.activity.mDecor;          if (v != null) {              if (r.activity.mVisibleFromServer) {                  mNumVisibleActivities--;              }              IBinder wtoken = v.getWindowToken();              if (r.activity.mWindowAdded) {                  if (r.onlyLocalRequest) {                      // Hold off on removing this until the new activity&#39;s                      // window is being added.                      r.mPendingRemoveWindow = v;                      r.mPendingRemoveWindowManager = wm;                  } else {                      wm.removeViewImmediate(v);//看这里，看这里                  }              }              if (wtoken != null &amp;&amp; r.mPendingRemoveWindow == null) {                  WindowManagerGlobal.getInstance().closeAll(wtoken,                          r.activity.getClass().getName(), &quot;Activity&quot;);              }              r.activity.mDecor = null;          }          if (r.mPendingRemoveWindow == null) {              // If we are delaying the removal of the activity window, then              // we can&#39;t clean up all windows here.  Note that we can&#39;t do              // so later either, which means any windows that aren&#39;t closed              // by the app will leak.  Well we try to warning them a lot              // about leaking windows, because that is a bug, so if they are              // using this recreate facility then they get to live with leaks.              WindowManagerGlobal.getInstance().closeAll(token,                      r.activity.getClass().getName(), &quot;Activity&quot;);          }          // Mocked out contexts won&#39;t be participating in the normal          // process lifecycle, but if we&#39;re running with a proper          // ApplicationContext we need to have it tear down things          // cleanly.          Context c = r.activity.getBaseContext();          if (c instanceof ContextImpl) {              ((ContextImpl) c).scheduleFinalCleanup(                      r.activity.getClass().getName(), &quot;Activity&quot;);          }      }      if (finishing) {          try {              ActivityManagerNative.getDefault().activityDestroyed(token);          } catch (RemoteException ex) {              // If the system process has died, it&#39;s game over for everyone.          }      }      mSomeActivitiesChanged = true;  }</code></pre><p> 看代码中的wm.removeViewImmediate方法，还是走到WindowManagerImpl类中的removeViewImmediate，代码如下：<br>WindowManagerImpl.java</p><pre><code class="java">@Override  public void removeViewImmediate(View view) {      mGlobal.removeView(view, true);  }</code></pre><p> 好熟悉啊，还是走到了WindowManagerGlobal类中的removeView，代码如下：<br>WindowManagerGlobal.java</p><pre><code class="java">public void removeView(View view, boolean immediate) {      if (view == null) {          throw new IllegalArgumentException(&quot;view must not be null&quot;);      }      synchronized (mLock) {          int index = findViewLocked(view, true);          View curView = mRoots.get(index).getView();          removeViewLocked(index, immediate);          if (curView == view) {              return;          }          throw new IllegalStateException(&quot;Calling with view &quot; + view                  + &quot; but the ViewAncestor is attached to &quot; + curView);      }  }  private void removeViewLocked(int index, boolean immediate) {      ViewRootImpl root = mRoots.get(index);      View view = root.getView();      if (view != null) {          InputMethodManager imm = InputMethodManager.getInstance();          if (imm != null) {              imm.windowDismissed(mViews.get(index).getWindowToken());          }      }      boolean deferred = root.die(immediate);      if (view != null) {          view.assignParent(null);          if (deferred) {              mDyingViews.add(view);          }      }  }</code></pre><p> 跟着代码继续走，到了ViewRootImpl类中的die，代码如下：<br>ViewRootImpl.java</p><pre><code class="java">/**      * @param immediate True, do now if not in traversal. False, put on queue and do later.      * @return True, request has been queued. False, request has been completed.      */      boolean die(boolean immediate) {          // Make sure we do execute immediately if we are in the middle of a traversal or the damage          // done by dispatchDetachedFromWindow will cause havoc on return.          if (immediate &amp;&amp; !mIsInTraversal) {              doDie();              return false;          }          if (!mIsDrawing) {              destroyHardwareRenderer();          } else {              Log.e(TAG, &quot;Attempting to destroy the window while drawing!\n&quot; +                      &quot;  window=&quot; + this + &quot;, title=&quot; + mWindowAttributes.getTitle());          }          mHandler.sendEmptyMessage(MSG_DIE);          return true;      }      void doDie() {          checkThread();          if (LOCAL_LOGV) Log.v(TAG, &quot;DIE in &quot; + this + &quot; of &quot; + mSurface);          synchronized (this) {              if (mRemoved) {                  return;              }              mRemoved = true;              if (mAdded) {                  dispatchDetachedFromWindow();//看这里，看这里              }              if (mAdded &amp;&amp; !mFirst) {                  destroyHardwareRenderer();                  if (mView != null) {                      int viewVisibility = mView.getVisibility();                      boolean viewVisibilityChanged = mViewVisibility != viewVisibility;                      if (mWindowAttributesChanged || viewVisibilityChanged) {                          // If layout params have been changed, first give them                          // to the window manager to make sure it has the correct                          // animation info.                          try {                              if ((relayoutWindow(mWindowAttributes, viewVisibility, false)                                      &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {                                  mWindowSession.finishDrawing(mWindow);                              }                          } catch (RemoteException e) {                          }                      }                      mSurface.release();                  }              }              mAdded = false;          }          WindowManagerGlobal.getInstance().doRemoveView(this);      }</code></pre><p> 在doDie里面调用了dispatchDetachedFromWindow()方法，代码如下：<br>ViewRootImpl.java</p><pre><code class="java">void dispatchDetachedFromWindow() {          if (mView != null &amp;&amp; mView.mAttachInfo != null) {              mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(false);              mView.dispatchDetachedFromWindow();//看这里，看这里          }          mAccessibilityInteractionConnectionManager.ensureNoConnection();          mAccessibilityManager.removeAccessibilityStateChangeListener(                  mAccessibilityInteractionConnectionManager);          mAccessibilityManager.removeHighTextContrastStateChangeListener(                  mHighContrastTextManager);          removeSendWindowContentChangedCallback();          destroyHardwareRenderer();          setAccessibilityFocus(null, null);          mView.assignParent(null);          mView = null;          mAttachInfo.mRootView = null;          mSurface.release();          if (mInputQueueCallback != null &amp;&amp; mInputQueue != null) {              mInputQueueCallback.onInputQueueDestroyed(mInputQueue);              mInputQueue.dispose();              mInputQueueCallback = null;              mInputQueue = null;          }          if (mInputEventReceiver != null) {              mInputEventReceiver.dispose();              mInputEventReceiver = null;          }          try {              mWindowSession.remove(mWindow);          } catch (RemoteException e) {          }          // Dispose the input channel after removing the window so the Window Manager          // doesn&#39;t interpret the input channel being closed as an abnormal termination.          if (mInputChannel != null) {              mInputChannel.dispose();              mInputChannel = null;          }          mDisplayManager.unregisterDisplayListener(mDisplayListener);          unscheduleTraversals();      }</code></pre><p> 还记着在WindowManagerGlobal里面的root.setView(view, wparams, panelParentView);调用吧，这里的mView.dispatchDetachedFromWindow();这个mView也即是上面传过来的view。也就是先看DecorView即ViewGroup里面的dispatchDetachedFromWindow，代码如下：<br>ViewGroup.java</p><pre><code class="java">@Override  void dispatchDetachedFromWindow() {      // If we still have a touch target, we are still in the process of      // dispatching motion events to a child; we need to get rid of that      // child to avoid dispatching events to it after the window is torn      // down. To make sure we keep the child in a consistent state, we      // first send it an ACTION_CANCEL motion event.      cancelAndClearTouchTargets(null);      // Similarly, set ACTION_EXIT to all hover targets and clear them.      exitHoverTargets();      // In case view is detached while transition is running      mLayoutCalledWhileSuppressed = false;      // Tear down our drag tracking      mDragNotifiedChildren = null;      if (mCurrentDrag != null) {          mCurrentDrag.recycle();          mCurrentDrag = null;      }      final int count = mChildrenCount;      final View[] children = mChildren;      for (int i = 0; i &lt; count; i++) {          children[i].dispatchDetachedFromWindow();//这里会先调子类的dispatchDetachedFromWindow      }      clearDisappearingChildren();      final int transientCount = mTransientViews == null ? 0 : mTransientIndices.size();      for (int i = 0; i &lt; transientCount; ++i) {          View view = mTransientViews.get(i);          view.dispatchDetachedFromWindow();      }      super.dispatchDetachedFromWindow();//然后这里才调用自己的。  }</code></pre><p> 这之后又到View的dispatchDetachedFromWindow了，代码如下：<br>View.java</p><pre><code class="java">void dispatchDetachedFromWindow() {          AttachInfo info = mAttachInfo;          if (info != null) {              int vis = info.mWindowVisibility;              if (vis != GONE) {                  onWindowVisibilityChanged(GONE);              }          }          onDetachedFromWindow();//绕了一大圈，还是找到你了。快看快看，揪出来了。          onDetachedFromWindowInternal();          InputMethodManager imm = InputMethodManager.peekInstance();          if (imm != null) {              imm.onViewDetachedFromWindow(this);          }          ListenerInfo li = mListenerInfo;          final CopyOnWriteArrayList&lt;OnAttachStateChangeListener&gt; listeners =                  li != null ? li.mOnAttachStateChangeListeners : null;          if (listeners != null &amp;&amp; listeners.size() &gt; 0) {              // NOTE: because of the use of CopyOnWriteArrayList, we *must* use an iterator to              // perform the dispatching. The iterator is a safe guard against listeners that              // could mutate the list by calling the various add/remove methods. This prevents              // the array from being modified while we iterate it.              for (OnAttachStateChangeListener listener : listeners) {                  listener.onViewDetachedFromWindow(this);              }          }          if ((mPrivateFlags &amp; PFLAG_SCROLL_CONTAINER_ADDED) != 0) {              mAttachInfo.mScrollContainers.remove(this);              mPrivateFlags &amp;= ~PFLAG_SCROLL_CONTAINER_ADDED;          }          mAttachInfo = null;          if (mOverlay != null) {              mOverlay.getOverlayView().dispatchDetachedFromWindow();          }      }</code></pre><p>看代码终于找到了onDetachedFromWindow的调用地方了。<br>这里总结下：</p><p>1.onAttachedToWindow调用顺序：ActivityThread.handleResumeActivity-&gt;WindowManagerImpl.addView-&gt;WindowManagerGlobal.addView-&gt;ViewRootImpl.performTraversals-&gt;ViewGroup.dispatchAttachedToWindow-&gt;View.dispatchAttachedToWindow-&gt;onAttachedToWindow</p><p>2.onDetachedFromWindow调用顺序：ActivityThread.handleDestroyActivity-&gt;WindowManagerImpl.removeViewImmediate-&gt;WindowManagerGlobal.removeView-&gt;ViewRootImpl.die-&gt;ViewRootImpl.doDie-&gt;ViewRootImpl.dispatchDetachedFromWindow-&gt;ViewGroup.dispatchDetachedFromWindow-&gt;View.dispatchDetachedFromWindow-&gt;onDetachedToWindow</p><p>3.onAttachedToWindow和onDetachedFromWindow的调用与visibility无关。</p><p>4.onAttachedToWindow是先调用自己，然后调用儿子View的。onDetachedFromWindow是先调用儿子View的，然后再调用自己的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-示例&quot;&gt;&lt;a href=&quot;#1-示例&quot; class=&quot;headerlink&quot; title=&quot;1.示例&quot;&gt;&lt;/a&gt;1.示例&lt;/h3&gt;&lt;p&gt;先上测试代码：&lt;br&gt;MyView.java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public clas
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="onAttachedToWindow和onDetachedFromWindow,源码解析" scheme="http://yoursite.com/tags/onAttachedToWindow%E5%92%8ConDetachedFromWindow-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title> 在git命令行下查看git stash里面文件的内容</title>
    <link href="http://yoursite.com/2018/01/08/%E5%9C%A8git%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E6%9F%A5%E7%9C%8Bgit-stash%E9%87%8C%E9%9D%A2%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9/"/>
    <id>http://yoursite.com/2018/01/08/在git命令行下查看git-stash里面文件的内容/</id>
    <published>2018-01-08T12:51:31.000Z</published>
    <updated>2018-07-30T14:34:37.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>在使用git的时候往往会保存一些东西，在保存的时候使用的就是git stash，强大的git使得保存修改和恢复修改变的很容易，但有时候时间久了不记得stash里面的内容是什么了。</p><h4 id="原英文地址"><a href="#原英文地址" class="headerlink" title="原英文地址"></a>原英文地址</h4><p>通过在stackflow里面查找，找到了一个好的方法。其网址是：<br><a href="http://stackoverflow.com/questions/10725729/git-see-whats-in-a-stash-without-applying-stash" target="_blank" rel="noopener">http://stackoverflow.com/questions/10725729/git-see-whats-in-a-stash-without-applying-stash</a> </p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>当利用git stash pop弹出来会有些耗费时间，这时可以使用git stash show来查看stash里面保存的内容。<br>在git bash上可以使用git –help stash来查看git stash命令的用法，当在stash后加show时，官方给出的介绍如下：</p><p>show stash</p><p>Show the changes recorded in the stash as a diff between the stashed state and its original parent. When no <stash> is given, shows the latest one. By default, the command shows the diffstat, but it will accept any format known to git diff(e.g., git stash show -p stash@{1} to view the second most recent stash in patch form). You can use stash.showStat and/or stash.showPatch config variables to change the default behavior.</stash></p><p>翻译如下：显示修改在stash状态与原版本之间的不同变化。当没有<stash>给定时，显示最新stash的变化。默认情况下，命令显示diffstat，它可以接受任何已知的git diff格式（例如，git stash show -p stash@{1}是查看第二最近stash的变化）。你可以使用stash.showstat和/或stash.showpatch配置变量来改变默认的行为。</stash></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>也就是使用git stash show -p stash@{1}来查看stash的内容变化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h4&gt;&lt;p&gt;在使用git的时候往往会保存一些东西，在保存的时候使用的就是git stash，强大的git使得保存修改和恢复修改变的很容易，但有时候时间久
      
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="查看git bash内容" scheme="http://yoursite.com/tags/%E6%9F%A5%E7%9C%8Bgit-bash%E5%86%85%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>通过adb shell命令查看当前交互的Activity名称</title>
    <link href="http://yoursite.com/2018/01/08/%E9%80%9A%E8%BF%87adb-shell%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E4%BA%A4%E4%BA%92%E7%9A%84Activity%E5%90%8D%E7%A7%B0/"/>
    <id>http://yoursite.com/2018/01/08/通过adb-shell命令查看当前交互的Activity名称/</id>
    <published>2018-01-08T12:46:09.000Z</published>
    <updated>2018-07-30T14:34:37.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>在做android逆向的时候，有时候会需要知道当前的界面处于哪个Activity，这时候就可以使用adb shell命令来查看当前与用户交互的Activity名称。</p><h4 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h4><p>先给出原文地址：<br><a href="http://stackoverflow.com/questions/11549366/print-the-current-back-stack-in-the-log/26424943#26424943" target="_blank" rel="noopener">http://stackoverflow.com/questions/11549366/print-the-current-back-stack-in-the-log/26424943#26424943</a></p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>有如下几种方法可以获取：</p><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><pre><code>adb shell dumpsys activity activities | sed -En -e &#39;/Running activities/,/Run #0/p&#39;</code></pre><p><img src="http://img.blog.csdn.net/20170110121929007?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="方法一"><br>其中TaskRecord即为查询到的记录。其中com.sina.weibo为包名，.VisitorMainTabActivity为对应的Activity名称。</p><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><pre><code>adb shell dumpsys activity | grep -i run</code></pre><p>查询结果为：<br><img src="http://img.blog.csdn.net/20170110122114759?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="方法二"></p><h5 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h5><pre><code>adb shell dumpsys activity | grep &quot;mFoc&quot;</code></pre><p>查询结果为：<br><img src="http://img.blog.csdn.net/20170110122247214?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="方法三"><br>其中mFocusedActivity就是当前和用户交互的Activity。<br>如果在Windows下使用时，则先通过adb shell进入到adb shell里，然后把adb shell去了，再将余下的复制到$后面进行执行，例如：<br><img src="http://img.blog.csdn.net/20170110122816847?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="在shell下执行grep语句"><br>这样就不会提示：“grep”不是内部或外部命令，也不是可运行查询了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h4&gt;&lt;p&gt;在做android逆向的时候，有时候会需要知道当前的界面处于哪个Activity，这时候就可以使用adb shell命令来查看当前与用户交互
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="adb查看交互Activity名称" scheme="http://yoursite.com/tags/adb%E6%9F%A5%E7%9C%8B%E4%BA%A4%E4%BA%92Activity%E5%90%8D%E7%A7%B0/"/>
    
  </entry>
  
</feed>
